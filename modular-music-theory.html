<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modular Music Theory Tools</title>
    <link rel="stylesheet" href="unified-chord-explorer.css">
    <style>
        /* ==================== THEME SYSTEM ==================== */
        :root {
            /* Base structure */
            --header-height: 50px;
            --footer-height: 140px;
            --font-tech: 'Courier New', 'Consolas', monospace;
            --font-ui: 'Segoe UI', 'Verdana', sans-serif;
            
            /* Module colors (shared across themes - WCAG AAA compliant) */
            --mod-input-color: #fbbf24;      /* Brighter Amber */
            --mod-db-color: #22d3ee;         /* Brighter Cyan */
            --mod-score-color: #cbd5e1;      /* Lighter Grey */
            --mod-prog-color: #e879f9;       /* Brighter Magenta */
            --mod-solar-color: #22d3ee;      /* Brighter Teal */
            --mod-ref-color: #fb923c;        /* Brighter Orange */
            --mod-tool-color: #34d399;       /* Brighter Green */
        }

        /* THEME A: Clean DAW / Logic-style (subtle color bands) */
        body[data-theme="clean-daw"] {
            --bg-app: #18181b;
            --bg-panel: #27272a;
            --bg-header: #3f3f46;
            --bg-input: #09090b;
            
            --accent-primary: #60a5fa; /* Improved contrast from #3b82f6 */
            --accent-secondary: #34d399; /* Improved contrast from #10b981 */
            --accent-glow: rgba(96, 165, 250, 0.15);
            --accent-grid: rgba(255, 255, 255, 0.03);
            
            --text-main: #ffffff; /* Pure white for max contrast */
            --text-muted: #d4d4d8; /* Lighter gray for better readability */
            --text-highlight: #93c5fd;
            
            --border-light: #52525b; /* More visible borders */
            --border-hover: #60a5fa;
            
            --radius-sm: 2px;
            --radius-md: 4px;
        }

        /* THEME B: Channel Strip DAW (Reaper-ish) */
        body[data-theme="channel-strip"] {
            --bg-app: #0f172a;
            --bg-panel: #1e293b;
            --bg-header: #334155;
            --bg-input: #020617; /* Darker input background */
            
            --accent-primary: #38bdf8;
            --accent-secondary: #22d3ee;
            --accent-glow: rgba(56, 189, 248, 0.2);
            --accent-grid: rgba(56, 189, 248, 0.04);
            
            --text-main: #f8fafc;
            --text-muted: #cbd5e1; /* Lighter blue-gray */
            --text-highlight: #bae6fd;
            
            --border-light: #64748b;
            --border-hover: #38bdf8;
            
            --radius-sm: 1px;
            --radius-md: 2px;
        }

        /* THEME C: Matrix FX (darker, more glow) */
        body[data-theme="matrix-fx"] {
            --bg-app: #000000;
            --bg-panel: #050a0f;
            --bg-header: #0a1520;
            --bg-input: #000000;
            
            --accent-primary: #00f3ff;
            --accent-secondary: #00ff41;
            --accent-glow: rgba(0, 243, 255, 0.3);
            --accent-grid: rgba(0, 243, 255, 0.1);
            
            --text-main: #e0f7fa;
            --text-muted: #8ab4c5; /* Lighter cyan-gray */
            --text-highlight: #00f3ff;
            
            --border-light: #2a5c7d;
            --border-hover: #00f3ff;
            
            --radius-sm: 0px;
            --radius-md: 0px;
        }

        /* THEME D: Steam 2000 (Retro Olive/Green) */
        body[data-theme="steam-2000"] {
            --bg-app: #1e251e;
            --bg-panel: #2a352b;
            --bg-header: #3d4c3f;
            --bg-input: #121612; /* Darker input */
            
            --accent-primary: #d4e09b; /* Lighter olive for contrast */
            --accent-secondary: #a8b970;
            --accent-glow: rgba(198, 212, 126, 0.15);
            --accent-grid: rgba(198, 212, 126, 0.06);
            
            --text-main: #f0f5e9; /* Brighter text */
            --text-muted: #b8c4b0; /* Lighter muted text */
            --text-highlight: #ffffff;
            
            --border-light: #5c7060;
            --border-hover: #d4e09b;
            
            --radius-sm: 0px;
            --radius-md: 0px;
            
            /* Override fonts for that retro feel */
            --font-ui: 'Verdana', 'Tahoma', sans-serif;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        /* Accessibility: Focus Styles */
        :focus-visible {
            outline: 2px solid var(--accent-primary);
            outline-offset: 2px;
        }
        
        body {
            background-color: var(--bg-app);
            background-image: 
                linear-gradient(var(--accent-grid) 1px, transparent 1px),
                linear-gradient(90deg, var(--accent-grid) 1px, transparent 1px);
            background-size: 20px 20px;
            color: var(--text-main);
            font-family: var(--font-ui);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            font-size: 12px;
        }

        /* ==================== CONTROL DECK (TOP) ==================== */
        .control-deck {
            height: var(--header-height);
            background: rgba(5, 10, 15, 0.9);
            border-bottom: 1px solid var(--accent-primary);
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 24px;
                            ${items.join('')}
                        </div>
                    `;
            margin: 0 !important; 
            width: auto !important;
            background: black !important;
            border: 1px solid var(--accent-primary) !important;
            color: var(--accent-primary) !important;
            font-family: var(--font-tech) !important;
            text-transform: uppercase;
            height: 24px;
        }

        /* Hide internal titles since we have module headers */
        #number-generator-container h3 { display: none; }
        
        /* ==================== MAIN WORKSPACE ==================== */
        .workspace {
            flex: 1;
            display: grid;
            grid-template-columns: minmax(320px, auto) 1fr minmax(280px, auto);
            overflow: auto;
            background: transparent;
            padding: 10px;
            gap: 10px;
            align-items: start;
        }

        .workspace-column {
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow: visible;
            min-height: min-content;
        }
        
        .workspace-column.right-sidebar {
            position: sticky;
            top: calc(var(--header-height) + 10px);
            align-self: flex-start;
            max-height: calc(100vh - var(--header-height) - 20px);
            overflow-y: auto;
        }

        .workspace-column.center-stage {
            border: 1px solid var(--border-light);
            background: rgba(0,0,0,0.5);
            position: relative;
            padding: 0;
            gap: 10px;
            padding-bottom: 10px;
        }
        
        /* Corner decorations for center stage */
        .workspace-column.center-stage::before {
            content: '';
            position: absolute;
            top: -1px; left: -1px;
            width: 10px; height: 10px;
            border-top: 2px solid var(--accent-primary);
            border-left: 2px solid var(--accent-primary);
        }
        .workspace-column.center-stage::after {
            content: '';
            position: absolute;
            bottom: -1px; right: -1px;
            width: 10px; height: 10px;
            border-bottom: 2px solid var(--accent-primary);
            border-right: 2px solid var(--accent-primary);
        }

        /* ==================== BOTTOM DECK (PIANO) ==================== */
        .bottom-deck {
            min-height: auto;
            height: auto;
            background: linear-gradient(180deg, #0a0a0a 0%, #000000 100%);
            border-top: 2px solid var(--accent-primary);
            padding: 0;
            flex-shrink: 0;
            position: relative;
            z-index: 90;
            box-shadow: 
                0 -4px 20px rgba(0,0,0,0.8),
                0 -1px 0 var(--accent-primary),
                inset 0 1px 0 rgba(255,255,255,0.05);
        }
        
        /* Decorative corner accents for bottom deck */
        .bottom-deck::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 40px;
            height: 40px;
            border-top: 2px solid var(--accent-primary);
            border-left: 2px solid var(--accent-primary);
            opacity: 0.5;
        }
        
        .bottom-deck::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 40px;
            height: 40px;
            border-top: 2px solid var(--accent-primary);
            border-right: 2px solid var(--accent-primary);
            opacity: 0.5;
        }
        
        .bottom-deck-label {
            position: absolute;
            top: 4px;
            left: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
            font-family: var(--font-tech);
            font-size: 0.6rem;
            color: var(--accent-primary);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            z-index: 10;
            pointer-events: none;
        }
        
        .deck-icon {
            font-size: 0.8rem;
            filter: drop-shadow(0 0 4px var(--accent-primary));
        }
        
                    sidebar.innerHTML = `
                        <div style="padding:10px;">
                            <div style="margin-bottom:10px; font-weight:600; text-transform:uppercase; letter-spacing:0.04em; font-size:0.68rem; color:var(--text-secondary);">
                                Chord Grading (${mode})
                            </div>
                            ${items.join('')}
                        </div>
                    `;
        
        /* Tech decoration in header */
        body[data-theme="matrix-fx"] .module-header::before {
            content: '‚ñ† ';
            color: var(--accent-secondary);
            margin-right: 5px;
        }

        /* ==================== PER-MODULE COLOR THEMING ==================== */
        
        /* Theme A: Clean DAW - Subtle colored header bands only */
        body[data-theme="clean-daw"] .mod-input .module-header { color: var(--mod-input-color); }
        body[data-theme="clean-daw"] .mod-db .module-header { color: var(--mod-db-color); }
        body[data-theme="clean-daw"] .mod-score .module-header { color: var(--mod-score-color); }
        body[data-theme="clean-daw"] .mod-prog .module-header { color: var(--mod-prog-color); }
        body[data-theme="clean-daw"] .mod-solar .module-header { color: var(--mod-solar-color); }
        body[data-theme="clean-daw"] .mod-ref .module-header { color: var(--mod-ref-color); }
        body[data-theme="clean-daw"] .mod-tool .module-header { color: var(--mod-tool-color); }

        /* Theme B: Channel Strip - Header + left border with module color, body slightly tinted */
        body[data-theme="channel-strip"] .mod-input { 
            border-left: 3px solid var(--mod-input-color); 
            background: linear-gradient(90deg, rgba(245, 158, 11, 0.05) 0%, var(--bg-panel) 100%);
        }
        body[data-theme="channel-strip"] .mod-input .module-header { 
            color: var(--mod-input-color); 
            background: linear-gradient(90deg, rgba(245, 158, 11, 0.15) 0%, transparent 100%);
        }

        body[data-theme="channel-strip"] .mod-db { 
            border-left: 3px solid var(--mod-db-color);
            background: linear-gradient(90deg, rgba(0, 243, 255, 0.05) 0%, var(--bg-panel) 100%);
        }
        body[data-theme="channel-strip"] .mod-db .module-header { 
            color: var(--mod-db-color);
            background: linear-gradient(90deg, rgba(0, 243, 255, 0.15) 0%, transparent 100%);
        }

        body[data-theme="channel-strip"] .mod-score { 
            border-left: 3px solid var(--mod-score-color);
        }
        body[data-theme="channel-strip"] .mod-score .module-header { 
            color: var(--mod-score-color);
        }

        body[data-theme="channel-strip"] .mod-prog { 
            border-left: 3px solid var(--mod-prog-color);
            background: linear-gradient(90deg, rgba(217, 70, 239, 0.05) 0%, var(--bg-panel) 100%);
        }
        body[data-theme="channel-strip"] .mod-prog .module-header { 
            color: var(--mod-prog-color);
            background: linear-gradient(90deg, rgba(217, 70, 239, 0.15) 0%, transparent 100%);
        }

        body[data-theme="channel-strip"] .mod-solar { 
            border-left: 3px solid var(--mod-solar-color);
            background: linear-gradient(90deg, rgba(6, 182, 212, 0.05) 0%, var(--bg-panel) 100%);
        }
        body[data-theme="channel-strip"] .mod-solar .module-header { 
            color: var(--mod-solar-color);
            background: linear-gradient(90deg, rgba(6, 182, 212, 0.15) 0%, transparent 100%);
        }

        body[data-theme="channel-strip"] .mod-ref { 
            border-left: 3px solid var(--mod-ref-color);
            background: linear-gradient(90deg, rgba(249, 115, 22, 0.05) 0%, var(--bg-panel) 100%);
        }
        body[data-theme="channel-strip"] .mod-ref .module-header { 
            color: var(--mod-ref-color);
            background: linear-gradient(90deg, rgba(249, 115, 22, 0.15) 0%, transparent 100%);
        }

        body[data-theme="channel-strip"] .mod-tool { 
            border-left: 3px solid var(--mod-tool-color);
            background: linear-gradient(90deg, rgba(16, 185, 129, 0.05) 0%, var(--bg-panel) 100%);
        }
        body[data-theme="channel-strip"] .mod-tool .module-header { 
            color: var(--mod-tool-color);
            background: linear-gradient(90deg, rgba(16, 185, 129, 0.15) 0%, transparent 100%);
        }

        /* Theme C: Matrix FX - Strong accent with background wash */
        body[data-theme="matrix-fx"] .mod-input {
            border: 1px solid rgba(245, 158, 11, 0.3);
            background: radial-gradient(circle at top left, rgba(245, 158, 11, 0.08), var(--bg-panel));
        }
        body[data-theme="matrix-fx"] .mod-input .module-header { 
            color: var(--mod-input-color);
            text-shadow: 0 0 8px rgba(245, 158, 11, 0.5);
        }
        body[data-theme="matrix-fx"] .mod-input:hover {
            border-color: var(--mod-input-color);
            box-shadow: 0 0 20px rgba(245, 158, 11, 0.3);
        }

        body[data-theme="matrix-fx"] .mod-db {
            border: 1px solid rgba(0, 243, 255, 0.3);
            background: radial-gradient(circle at top left, rgba(0, 243, 255, 0.08), var(--bg-panel));
        }
        body[data-theme="matrix-fx"] .mod-db .module-header { 
            color: var(--mod-db-color);
            text-shadow: 0 0 8px rgba(0, 243, 255, 0.5);
        }
        body[data-theme="matrix-fx"] .mod-db:hover {
            border-color: var(--mod-db-color);
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.3);
        }

        body[data-theme="matrix-fx"] .mod-score {
            border: 1px solid var(--border-light);
        }
        body[data-theme="matrix-fx"] .mod-score .module-header { 
            color: var(--mod-score-color);
        }

        body[data-theme="matrix-fx"] .mod-prog {
            border: 1px solid rgba(217, 70, 239, 0.3);
            background: radial-gradient(circle at top left, rgba(217, 70, 239, 0.08), var(--bg-panel));
        }
        body[data-theme="matrix-fx"] .mod-prog .module-header { 
            color: var(--mod-prog-color);
            text-shadow: 0 0 8px rgba(217, 70, 239, 0.5);
        }
        body[data-theme="matrix-fx"] .mod-prog:hover {
            border-color: var(--mod-prog-color);
            box-shadow: 0 0 20px rgba(217, 70, 239, 0.3);
        }

        body[data-theme="matrix-fx"] .mod-solar {
            border: 1px solid rgba(6, 182, 212, 0.3);
            background: radial-gradient(circle at top left, rgba(6, 182, 212, 0.08), var(--bg-panel));
        }
        body[data-theme="matrix-fx"] .mod-solar .module-header { 
            color: var(--mod-solar-color);
            text-shadow: 0 0 8px rgba(6, 182, 212, 0.5);
        }
        body[data-theme="matrix-fx"] .mod-solar:hover {
            border-color: var(--mod-solar-color);
            box-shadow: 0 0 20px rgba(6, 182, 212, 0.3);
        }

        body[data-theme="matrix-fx"] .mod-ref {
            border: 1px solid rgba(249, 115, 22, 0.3);
            background: radial-gradient(circle at top left, rgba(249, 115, 22, 0.08), var(--bg-panel));
        }
        body[data-theme="matrix-fx"] .mod-ref .module-header { 
            color: var(--mod-ref-color);
            text-shadow: 0 0 8px rgba(249, 115, 22, 0.5);
        }
        body[data-theme="matrix-fx"] .mod-ref:hover {
            border-color: var(--mod-ref-color);
            box-shadow: 0 0 20px rgba(249, 115, 22, 0.3);
        }

        body[data-theme="matrix-fx"] .mod-tool {
            border: 1px solid rgba(16, 185, 129, 0.3);
            background: radial-gradient(circle at top left, rgba(16, 185, 129, 0.08), var(--bg-panel));
        }
        body[data-theme="matrix-fx"] .mod-tool .module-header { 
            color: var(--mod-tool-color);
            text-shadow: 0 0 8px rgba(16, 185, 129, 0.5);
        }
        body[data-theme="matrix-fx"] .mod-tool:hover {
            border-color: var(--mod-tool-color);
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.3);
        }

        .module-content {
            padding: 10px;
            overflow: visible;
            background: transparent;
            display: flex;
            flex-direction: column;
        }
        
        /* Specific Module Tweaks */
        #sheet-music-container {
            background: #e0e0e0;
            border: 2px solid var(--border-light);
            min-height: 180px;
            max-height: none;
            display: flex;
            justify-content: center;
            padding: 20px;
            filter: invert(1) hue-rotate(180deg);
        }
        
        #chord-explorer-container {
            overflow: visible;
            display: flex;
            flex-direction: column;
            width: 100%;
        }

        /* ==================== PROGRESSION BUILDER STYLES ==================== */
        .progression-builder-ui {
            display: flex;
            flex-direction: column;
            gap: 12px;
            font-family: var(--font-ui);
        }
        
        .pb-top {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: flex-start;
        }
        
        .pb-left {
            flex: 1;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .pb-input {
            background: var(--bg-input);
            border: 1px solid var(--border-light);
            padding: 10px;
            border-radius: var(--radius-sm);
        }
        
        .pb-input-numbers {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            min-height: 32px;
            align-items: center;
        }
        
        .pb-chip {
            background: var(--accent-primary);
            color: #000;
            padding: 4px 8px;
            border-radius: var(--radius-sm);
            font-size: 0.85rem;
            font-weight: 600;
            font-family: var(--font-tech);
        }
        
        .pb-hint {
            color: var(--text-muted);
            font-size: 0.85rem;
            font-style: italic;
        }
        
        .pb-keyscale {
            margin-top: 6px;
            color: var(--accent-secondary);
            font-size: 0.8rem;
            font-family: var(--font-tech);
        }
        
        .pb-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .pg-target {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: center;
        }
        
        .pg-degree-list {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }
        
        .pg-degree-btn {
            font-size: 0.75rem;
            padding: 4px 8px !important;
        }
        
        .pb-explore {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .pb-label {
            font-size: 0.85rem;
            color: var(--text-main);
            font-family: var(--font-tech);
        }
        
        .pb-select {
            flex: 1;
            min-width: 150px;
        }
        
        .pb-regenerate {
            white-space: nowrap;
        }
        
        .pb-pad {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
            margin-top: 10px;
        }
        
        .pb-pad-wrap {
            position: relative;
            width: 180px;
            height: 180px;
            margin: 20px 30px;
        }
        
        .pb-axis-label {
            position: absolute;
            font-size: 0.65rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            font-family: var(--font-tech);
            letter-spacing: 1px;
            white-space: nowrap;
        }
        
        .pb-axis-top { top: -20px; left: 50%; transform: translateX(-50%); }
        .pb-axis-bottom { bottom: -20px; left: 50%; transform: translateX(-50%); }
        .pb-axis-left { left: -35px; top: 50%; transform: translateY(-50%) rotate(-90deg); }
        .pb-axis-right { right: -35px; top: 50%; transform: translateY(-50%) rotate(90deg); }
        
        .pb-axis-badge {
            font-size: 0.6rem;
            margin-left: 3px;
        }
        
        .pb-axis-sub {
            font-size: 0.6rem;
            display: block;
            margin-top: 2px;
        }
        
        .pb-pad-surface {
            width: 100%;
            height: 100%;
            background: var(--bg-input);
            border: 1px solid var(--border-light);
            position: relative;
            cursor: crosshair;
            overflow: hidden;
        }
        
        .pb-status {
            display: flex;
            gap: 8px;
            width: 100%;
            justify-content: center;
        }

        .pb-card {
            background: var(--bg-input);
            border: 1px solid var(--border-light);
            border-radius: 4px;
            padding: 6px 10px;
            text-align: center;
            flex: 1;
            min-width: 80px;
        }
        
        .pb-card-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: 4px;
            font-family: var(--font-tech);
        }
        
        .pb-card-value {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-main);
            margin-bottom: 2px;
        }
        
        .pb-card-sub {
            font-size: 0.7rem;
            color: var(--text-muted);
        }

        .pb-chord-explanation {
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-bottom: 2px;
            line-height: 1.2;
        }

        .pb-chord-degree {
            font-size: 0.65rem;
            color: var(--text-muted);
            text-align: center;
        }

        .pb-progression-controls {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-top: 8px;
        }

        .pb-suggest-alternatives,
        .pb-show-analysis {
            font-size: 0.8rem;
            padding: 6px 12px;
        }
        
        .pb-sub-panel {
            margin-top: 12px;
            padding: 12px;
            background: var(--bg-input);
            border: 1px solid var(--border-light);
        }
        
        .pb-sub-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .pb-progression-display {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 12px;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
        }

        .pb-chord-item {
            background: var(--bg-input);
            border: 1px solid var(--border-light);
            border-radius: 4px;
            padding: 8px;
            min-width: 120px;
            flex: 1 1 120px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .pb-chord-main {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-left: 8px;
            margin-bottom: 4px;
        }

        .pb-chord-name {
            font-weight: 700;
            font-size: 1.1rem;
            color: var(--text-main);
        }

        .pb-chord-grade {
            font-size: 0.7rem;
            font-weight: 600;
        }

        /* Mini Chord Strip */
        .mini-chord-strip {
            display: flex;
            gap: 8px;
            padding: 8px 12px;
            overflow-x: auto;
            overflow-y: hidden;
            flex-wrap: nowrap;
            background: rgba(0,0,0,0.3);
            border-bottom: 1px solid var(--border-light);
            min-height: 50px;
            align-items: center;
        }

        /* Piano overrides */
        #piano-container {
            height: auto;
            min-height: auto;
            width: 100%;
            overflow-x: auto;
            overflow-y: visible;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: flex-start;
            padding: 16px 8px 0 8px;
            background: 
                radial-gradient(ellipse at center top, rgba(0, 243, 255, 0.03) 0%, transparent 50%),
                linear-gradient(180deg, rgba(0,0,0,0.5) 0%, #000000 100%);
            position: relative;
        }
        
        /* Add subtle grid pattern to piano container */
        #piano-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                linear-gradient(rgba(255,255,255,0.01) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.01) 1px, transparent 1px);
            background-size: 20px 20px;
            pointer-events: none;
            opacity: 0.5;
        }

        /* ==================== RESPONSIVE ==================== */
        @media (max-width: 1200px) {
            .workspace {
                grid-template-columns: 300px 1fr; /* Drop right sidebar */
            }
            .workspace-column.right-sidebar {
                display: none; /* Or move to tabs? For now hide or stack */
            }
        }

        @media (max-width: 900px) {
            body { overflow: auto; height: auto; display: block; }
            .control-deck { 
                height: auto; 
                flex-wrap: wrap; 
                padding: 12px; 
                position: sticky;
                top: 0;
            }
            .workspace {
                display: flex;
                flex-direction: column;
                height: auto;
                overflow: visible;
            }
            .workspace-column {
                height: auto;
                overflow: visible;
                border: none;
            }
            .bottom-deck {
                position: sticky;
                bottom: 0;
                height: 120px;
            }
        }
        
        /* Utilities */
        .btn-icon { 
            background: transparent; 
            border: 1px solid transparent; 
            color: var(--text-muted); 
            cursor: pointer; 
            font-family: var(--font-tech);
            padding: 2px 6px;
        }
        .btn-icon:hover { 
            color: var(--accent-primary); 
            border-color: var(--accent-primary);
            background: rgba(0, 243, 255, 0.1);
        }
        
        /* Scrollbars */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #000; border-left: 1px solid var(--border-light); }
        ::-webkit-scrollbar-thumb { background: var(--border-light); border: 1px solid #000; }
        ::-webkit-scrollbar-thumb:hover { background: var(--accent-primary); }
        
        /* Global Button Styles for injected modules */
        button {
            font-family: var(--font-tech) !important;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-radius: 0 !important; /* Square buttons */
        }
        
        .btn {
            background: var(--bg-input);
            border: 1px solid var(--border-light);
            color: var(--text-main);
            padding: 8px 12px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s ease;
        }
        
        .btn:hover {
            border-color: var(--accent-primary);
            background: rgba(0, 243, 255, 0.1);
            color: var(--accent-primary);
        }
        
        .btn-primary {
            background: var(--accent-primary);
            color: #000;
            border-color: var(--accent-primary);
        }
        
        .btn-primary:hover {
            background: var(--accent-secondary);
            border-color: var(--accent-secondary);
        }
        
        /* Input Styles */
        input, select {
            background: #000 !important;
            border: 1px solid var(--border-light) !important;
            color: var(--accent-primary) !important;
            font-family: var(--font-tech) !important;
            border-radius: 0 !important;
        }
        input:focus, select:focus {
            border-color: var(--accent-primary) !important;
            box-shadow: 0 0 8px var(--accent-glow) !important;
            outline: none;
        }
        
        /* ==================== SIMPLIFIED CONTROL DECK ==================== */
        .primary-input-section {
            border-left: 1px solid var(--border-light);
            padding-left: 16px;
        }
        
        .grading-section {
            border-left: 1px solid var(--border-light);
            padding-left: 12px;
        }
        
        .secondary-controls {
            border-left: 1px solid var(--border-light);
            padding-left: 12px;
        }
        
        /* ==================== DROPDOWN PANELS ==================== */
        .tools-dropdown-panel,
        #settings-dropdown-panel,
        #help-dropdown-panel {
            position: absolute;
            top: calc(100% + 4px);
            right: 0;
            background: var(--bg-panel);
            border: 1px solid var(--border-light);
            padding: 8px;
            min-width: 200px;
            max-height: 0;
            overflow: hidden;
            opacity: 0;
            transition: all 0.2s ease;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        
        .tools-dropdown-panel.open,
        #settings-dropdown-panel.open,
        #help-dropdown-panel.open {
            max-height: 400px;
            opacity: 1;
        }
        
        .module-toggle-item {
            display: flex;
            align-items: center;
            padding: 6px 8px;
            margin-bottom: 4px;
            background: var(--bg-input);
            border: 1px solid var(--border-light);
            transition: all 0.2s ease;
        }
        
        .module-toggle-item:hover {
            border-color: var(--accent-primary);
            background: rgba(0, 243, 255, 0.05);
        }
        
        .module-toggle-item input[type="checkbox"] {
            margin-right: 8px;
            cursor: pointer;
            width: 16px;
            height: 16px;
            accent-color: var(--accent-primary);
        }
        
        .module-toggle-item label {
            cursor: pointer;
            flex: 1;
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            user-select: none;
        }
        
        .module-toggle-item:hover label {
            color: var(--accent-primary);
        }
        
        /* ==================== TUTORIAL SYSTEM ==================== */
        .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 9998;
            display: none;
            pointer-events: none;
        }
        
        .tutorial-overlay.active {
            display: block;
        }
        
        .tutorial-highlight {
            position: absolute;
            border: 3px solid var(--accent-primary);
            box-shadow: 0 0 20px var(--accent-primary), inset 0 0 20px rgba(0, 243, 255, 0.2);
            pointer-events: none;
            z-index: 9999;
            animation: pulse-highlight 2s infinite;
        }
        
        @keyframes pulse-highlight {
            0%, 100% { box-shadow: 0 0 20px var(--accent-primary), inset 0 0 20px rgba(0, 243, 255, 0.2); }
            50% { box-shadow: 0 0 40px var(--accent-primary), inset 0 0 40px rgba(0, 243, 255, 0.3); }
        }
        
        .tutorial-tooltip {
            position: fixed;
            background: var(--bg-panel);
            border: 2px solid var(--accent-primary);
            padding: 16px 20px;
            max-width: 400px;
            z-index: 10000;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.8);
            font-family: var(--font-ui);
            display: none;
        }
        
        .tutorial-tooltip.active {
            display: block;
        }
        
        .tutorial-tooltip-title {
            font-family: var(--font-tech);
            font-size: 0.9rem;
            color: var(--accent-primary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
            border-bottom: 1px solid var(--border-light);
            padding-bottom: 6px;
        }
        
        .tutorial-tooltip-content {
            color: var(--text-main);
            font-size: 0.85rem;
            line-height: 1.5;
            margin-bottom: 12px;
        }
        
        .tutorial-tooltip-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }
        
        .tutorial-tooltip-actions button {
            padding: 6px 12px;
            font-size: 0.75rem;
        }
        
        /* Demo Mode Hover Tooltips */
        .demo-tooltip {
            position: absolute;
            background: var(--bg-panel);
            border: 1px solid var(--accent-primary);
            padding: 12px 16px;
            max-width: 300px;
            z-index: 10001;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.7);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-family: var(--font-ui);
            font-size: 0.8rem;
            line-height: 1.4;
            color: var(--text-main);
        }
        
        .demo-tooltip.show {
            opacity: 1;
        }
        
        .demo-tooltip-title {
            font-family: var(--font-tech);
            font-size: 0.75rem;
            color: var(--accent-primary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }
        
        /* Easy Mode Indicator */
        .easy-mode-badge {
            position: fixed;
            top: 60px;
            right: 20px;
            background: var(--accent-secondary);
            color: #000;
            padding: 8px 16px;
            font-family: var(--font-tech);
            font-size: 0.75rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            z-index: 9997;
            box-shadow: 0 4px 12px rgba(52, 211, 153, 0.4);
            animation: badge-glow 2s infinite;
        }

        /* Input Mode Toggle Buttons */
        .input-mode-btn {
            background: var(--bg-lighter);
            border: 1px solid var(--border-main);
            color: var(--text-dim);
            padding: 6px 12px;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: var(--font-ui);
        }
        
        .input-mode-btn:hover {
            background: var(--bg-panel);
            border-color: var(--accent-primary);
            color: var(--text-main);
        }
        
        .input-mode-btn.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: #000;
            font-weight: bold;
        }

        /* Word Analysis Panel */
        .word-analysis-panel {
            position: fixed;
            top: 80px;
            right: -350px;
            width: 340px;
            max-height: calc(100vh - 100px);
            background: var(--bg-panel);
            border: 1px solid var(--accent-primary);
            box-shadow: -4px 0 16px rgba(0, 0, 0, 0.7);
            z-index: 9000;
            transition: right 0.3s ease;
            display: flex;
            flex-direction: column;
        }
        
        .word-analysis-panel.active {
            right: 20px;
        }

        /* Word Settings Panel */
        .word-settings-panel {
            position: fixed;
            top: 80px;
            right: -350px;
            width: 340px;
            max-height: calc(100vh - 100px);
            background: var(--bg-panel);
            border: 1px solid var(--border-main);
            box-shadow: -4px 0 16px rgba(0, 0, 0, 0.7);
            z-index: 9000;
            transition: right 0.3s ease;
            display: flex;
            flex-direction: column;
        }
        
        .word-settings-panel.active {
            right: 20px;
        }

        .word-analysis-panel .panel-header,
        .word-settings-panel .panel-header {
            background: var(--bg-darker);
            border-bottom: 1px solid var(--border-light);
            padding: 12px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-family: var(--font-tech);
            font-size: 0.85rem;
            color: var(--text-main);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .word-analysis-panel .panel-content,
        .word-settings-panel .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .analysis-empty {
            color: var(--text-dim);
            font-style: italic;
            text-align: center;
            padding: 24px;
        }

        .analysis-section {
            margin-bottom: 16px;
            padding: 12px;
            background: var(--bg-lighter);
            border: 1px solid var(--border-main);
        }

        .analysis-section-title {
            font-family: var(--font-tech);
            font-size: 0.75rem;
            color: var(--accent-primary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .analysis-item {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            font-size: 0.85rem;
        }

        .analysis-item-label {
            color: var(--text-dim);
        }

        .analysis-item-value {
            color: var(--text-main);
            font-weight: bold;
        }

        .archetype-match {
            background: var(--bg-darker);
            border: 1px solid var(--accent-secondary);
            padding: 8px;
            margin-top: 8px;
        }

        .archetype-match-title {
            color: var(--accent-secondary);
            font-weight: bold;
            margin-bottom: 4px;
        }

        .archetype-match-confidence {
            color: var(--text-dim);
            font-size: 0.8rem;
        }

        /* Settings Panel Specific */
        .setting-group {
            margin-bottom: 20px;
        }

        .setting-group label {
            display: block;
            font-size: 0.85rem;
            color: var(--text-main);
            margin-bottom: 8px;
            font-family: var(--font-tech);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-size: 0.75rem;
        }

        .weight-slider {
            width: 100%;
            height: 6px;
            background: var(--bg-lighter);
            border: 1px solid var(--border-main);
            outline: none;
            cursor: pointer;
            -webkit-appearance: none;
        }

        .weight-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent-primary);
            cursor: pointer;
            border-radius: 50%;
        }

        .weight-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--accent-primary);
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        .weight-value {
            display: inline-block;
            margin-left: 8px;
            color: var(--accent-primary);
            font-weight: bold;
            min-width: 40px;
        }

        #reset-weights-btn {
            width: 100%;
            margin-top: 8px;
        }

        
        @keyframes badge-glow {
            0%, 100% { box-shadow: 0 4px 12px rgba(52, 211, 153, 0.4); }
            50% { box-shadow: 0 4px 20px rgba(52, 211, 153, 0.7); }
        }
        
        .demo-mode-badge {
            position: fixed;
            top: 100px;
            right: 20px;
            background: var(--accent-primary);
            color: #000;
            padding: 8px 16px;
            font-family: var(--font-tech);
            font-size: 0.75rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            z-index: 9997;
            box-shadow: 0 4px 12px rgba(96, 165, 250, 0.4);
        }
        
        /* Tutorial Step Counter */
        .tutorial-progress {
            position: fixed;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-panel);
            border: 1px solid var(--accent-primary);
            padding: 8px 20px;
            font-family: var(--font-tech);
            font-size: 0.75rem;
            color: var(--accent-primary);
            text-transform: uppercase;
            letter-spacing: 1px;
            z-index: 9997;
            display: none;
        }
        
        .tutorial-progress.active {
            display: block;
        }
    </style>
</head>
<body data-theme="clean-daw">
    <!-- TOP CONTROL DECK - SIMPLIFIED -->
    <div class="control-deck">
        <!-- App Brand -->
        <div class="app-brand">
            <span>THEORY_STUDIO</span>
        </div>
        
        <!-- Primary Input Section -->
        <div class="primary-input-section" style="display:flex; align-items:center; gap:12px;">
            <!-- Input Mode Toggle -->
            <div class="input-mode-toggle" style="display:flex; gap:4px;">
                <button id="input-mode-words" class="input-mode-btn active" title="Word Input Mode">üìù</button>
                <button id="input-mode-numbers" class="input-mode-btn" title="Number Input Mode">üî¢</button>
            </div>
            
            <!-- Main Input Field -->
            <input type="text" id="global-word-input" 
                   class="form-input word-mode-input" 
                   placeholder="Enter words: chase, woods, dark..."
                   style="width:300px; padding:6px 12px; font-size:0.8rem;">
            
            <input type="text" id="global-manual-numbers" 
                   class="form-input number-mode-input" 
                   placeholder="Enter degrees/chords..."
                   style="display:none; width:200px; padding:6px 12px; font-size:0.8rem; text-align:center;">
            
            <!-- Quick Actions -->
            <div class="quick-actions" style="display:flex; gap:6px;">
                <button id="word-randomize-btn" class="btn-icon" title="Randomize">üé≤</button>
                <button id="word-regenerate-btn" class="btn-icon" title="Regenerate">üîÑ</button>
                <button id="word-send-sheet-btn" class="btn-icon" title="To Sheet Music">üéº</button>
            </div>
        </div>
        
        <!-- Scale Controls (Compact) -->
        <div class="header-module" id="header-scale-controls">
            <div id="scale-library-container"></div>
        </div>
        
        <!-- Grading Mode (Simplified) -->
        <div class="grading-section" style="display:flex; align-items:center; gap:8px;">
            <select id="global-grading-type" class="form-input" style="font-size:0.75rem; padding:4px 8px; min-width:120px;">
                <option value="functional">Functional</option>
                <option value="emotional">Emotional</option>
                <option value="color">Color</option>
            </select>
        </div>
        
        <div style="flex: 1;"></div> <!-- Spacer -->
        
        <!-- Secondary Controls -->
        <div class="secondary-controls" style="display:flex; align-items:center; gap:8px;">
            <!-- Settings Menu -->
            <div class="settings-dropdown" style="position: relative;">
                <button id="settings-dropdown-btn" class="btn-icon" title="Settings & Options">‚öôÔ∏è</button>
                <div id="settings-dropdown-panel" class="tools-dropdown-panel">
                    <!-- Grading Settings -->
                    <div style="padding:8px; border-bottom:1px solid var(--border-light); margin-bottom:8px;">
                        <div style="font-size:0.7rem; color:var(--text-muted); margin-bottom:6px;">GRADING INFLUENCE</div>
                        <div style="display:flex; align-items:center; gap:6px; margin-bottom:4px;">
                            <span style="font-size:0.65rem; width:40px;">Visual</span>
                            <input type="range" id="visual-influence" min="0" max="100" value="80" style="width:60px; height:8px;">
                            <span id="visual-influence-value" style="font-size:0.65rem; width:30px;">80%</span>
                        </div>
                        <div style="display:flex; align-items:center; gap:6px;">
                            <span style="font-size:0.65rem; width:40px;">Logic</span>
                            <input type="range" id="behavior-influence" min="0" max="100" value="60" style="width:60px; height:8px;">
                            <span id="behavior-influence-value" style="font-size:0.65rem; width:30px;">60%</span>
                        </div>
                    </div>
                    
                    <!-- Word Analysis Settings -->
                    <div class="module-toggle-item">
                        <button id="word-settings-btn" style="width:100%; text-align:left; background:transparent; border:none; color:var(--text-muted); padding:6px; cursor:pointer;">
                            üìä Word Analysis Settings
                        </button>
                    </div>
                    
                    <!-- Module Toggles -->
                    <div style="border-top:1px solid var(--border-light); margin-top:8px; padding-top:8px;">
                        <div style="font-size:0.7rem; color:var(--text-muted); margin-bottom:6px;">MODULES</div>
                        <div class="module-toggle-item">
                            <input type="checkbox" id="toggle-mod-input" data-module="input" checked>
                            <label for="toggle-mod-input">Number Generator</label>
                        </div>
                        <div class="module-toggle-item">
                            <input type="checkbox" id="toggle-mod-ref" data-module="ref" checked>
                            <label for="toggle-mod-ref">Circle of Fifths</label>
                        </div>
                        <div class="module-toggle-item">
                            <input type="checkbox" id="toggle-mod-tool" data-module="tool" checked>
                            <label for="toggle-mod-tool">Container Chord</label>
                        </div>
                        <div class="module-toggle-item">
                            <input type="checkbox" id="toggle-mod-score" data-module="score" checked>
                            <label for="toggle-mod-score">Sheet Music</label>
                        </div>
                        <div class="module-toggle-item">
                            <input type="checkbox" id="toggle-mod-chord" data-module="chord" checked>
                            <label for="toggle-mod-chord">Chord Explorer</label>
                        </div>
                        <div class="module-toggle-item">
                            <input type="checkbox" id="toggle-mod-solar" data-module="solar">
                            <label for="toggle-mod-solar">Solar System</label>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- View Controls -->
            <button class="btn-icon" id="theme-switcher" title="Theme">üé®</button>
            <button class="btn-icon" id="toggle-layout" title="Layout">‚äû</button>
            
            <!-- Help & Tutorial -->
            <div class="help-dropdown" style="position: relative;">
                <button id="help-dropdown-btn" class="btn-icon" title="Help & Tutorials">?</button>
                <div id="help-dropdown-panel" class="tools-dropdown-panel">
                    <div class="module-toggle-item">
                        <button id="easy-mode-btn" style="width:100%; text-align:left; background:transparent; border:none; color:var(--text-muted); padding:6px; cursor:pointer;">
                            üéì Easy Mode
                        </button>
                    </div>
                    <div class="module-toggle-item">
                        <button id="demo-mode-btn" style="width:100%; text-align:left; background:transparent; border:none; color:var(--text-muted); padding:6px; cursor:pointer;">
                            üí° Demo Mode
                        </button>
                    </div>
                    <div class="module-toggle-item">
                        <button id="grading-tutorial-btn" style="width:100%; text-align:left; background:transparent; border:none; color:var(--text-muted); padding:6px; cursor:pointer;">
                            üìö Grading Tutorial
                        </button>
                    </div>
                    <div class="module-toggle-item">
                        <button id="grading-preview-btn" style="width:100%; text-align:left; background:transparent; border:none; color:var(--text-muted); padding:6px; cursor:pointer;">
                            üëÅÔ∏è Grading Preview
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Hidden elements for compatibility -->
        <div style="display:none;">
            <div id="grading-key-legend"></div>
            <div id="global-undo-btn"></div>
            <div id="global-redo-btn"></div>
            <div id="tools-dropdown-btn"></div>
            <div id="tools-dropdown-panel"></div>
        </div>
    </div>
    

    
    <!-- Tutorial System Elements -->
    <div id="tutorial-overlay" class="tutorial-overlay"></div>
    <div id="tutorial-highlight" class="tutorial-highlight" style="display: none;"></div>
    <div id="tutorial-tooltip" class="tutorial-tooltip">
        <div class="tutorial-tooltip-title" id="tutorial-title"></div>
        <div class="tutorial-tooltip-content" id="tutorial-content"></div>
        <div class="tutorial-tooltip-actions">
            <button class="btn" id="tutorial-skip">Skip Tutorial</button>
            <button class="btn-primary" id="tutorial-next">Next</button>
        </div>
    </div>
    <div id="tutorial-progress" class="tutorial-progress"></div>
    <div id="demo-tooltip" class="demo-tooltip">
        <div class="demo-tooltip-title" id="demo-tooltip-title"></div>
        <div id="demo-tooltip-content"></div>
    </div>

    <!-- Word Analysis Panel -->
    <div id="word-analysis-panel" class="word-analysis-panel">
        <div class="panel-header">
            <span>üìä Word Analysis</span>
            <button id="copy-lexical-log-btn" class="btn-icon" title="Copy lexical analysis log to clipboard" style="font-size: 0.7rem; padding: 2px 8px; margin-right: 8px;">üìã Copy Log</button>
            <button id="debug-log-btn" class="btn-icon" title="Show debug information" style="font-size: 0.7rem; padding: 2px 8px; margin-right: 8px;">üîç Debug</button>
            <button class="btn-icon" onclick="isUserDismissingPanel = true; document.getElementById('word-analysis-panel').classList.remove('active')">‚úï</button>
        </div>
        <div class="panel-content">
            <div id="word-analysis-content">
                <div class="analysis-empty">Enter words above to see analysis...</div>
            </div>
                <!-- Session Log: shows recent translations with quick actions -->
                <div id="lexical-session-log" style="margin-top:12px; border-top:1px solid rgba(255,255,255,0.03); padding-top:8px;">
                    <div style="display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:6px;">
                        <div style="font-weight:700; color:var(--accent-primary);">üóÇÔ∏è Session Log</div>
                        <div style="display:flex; gap:8px; align-items:center;">
                            <button id="export-lexical-log-btn" class="btn" style="font-size:0.75rem; padding:4px 8px;">Export JSON</button>
                            <button id="clear-lexical-log-btn" class="btn" style="font-size:0.75rem; padding:4px 8px;">Clear</button>
                        </div>
                    </div>
                    <div id="lexical-log-list" style="max-height:220px; overflow:auto; padding-right:6px;"></div>
                </div>
        </div>
    </div>

    <!-- Word Settings Panel -->
    <div id="word-settings-panel" class="word-settings-panel">
        <div class="panel-header">
            <span>‚öôÔ∏è Lexical Engine Settings</span>
            <button class="btn-icon" onclick="document.getElementById('word-settings-panel').classList.remove('active')">‚úï</button>
        </div>
        <div class="panel-content">
            <div class="setting-group">
                <label>Emotional Weight</label>
                <input type="range" id="weight-emotional" min="0" max="100" value="30" class="weight-slider">
                <span class="weight-value">30%</span>
            </div>
            <div class="setting-group">
                <label>Syllabic/Rhythm Weight</label>
                <input type="range" id="weight-syllabic" min="0" max="100" value="20" class="weight-slider">
                <span class="weight-value">20%</span>
            </div>
            <div class="setting-group">
                <label>Phonetic/Color Weight</label>
                <input type="range" id="weight-phonetic" min="0" max="100" value="15" class="weight-slider">
                <span class="weight-value">15%</span>
            </div>
            <div class="setting-group">
                <label>Semantic Context Weight</label>
                <input type="range" id="weight-semantic" min="0" max="100" value="25" class="weight-slider">
                <span class="weight-value">25%</span>
            </div>
            <div class="setting-group">
                <label>Archetype Matching Weight</label>
                <input type="range" id="weight-archetype" min="0" max="100" value="10" class="weight-slider">
                <span class="weight-value">10%</span>
            </div>
            <div class="setting-group">
                <button class="btn-primary" id="reset-weights-btn">Reset to Defaults</button>
            </div>
                <div class="setting-group">
                    <label><input type="checkbox" id="weight-aggressive"> Prefer dramatic / darker mappings</label>
                </div>
                <div class="setting-group">
                    <label><input type="checkbox" id="weight-key-variety" checked> Enable dynamic key selection (more variety)</label>
                </div>
                <div class="setting-group">
                    <label><input type="checkbox" id="weight-auto-send" checked> Auto-send to sheet music (immediate playback)</label>
                </div>
                <div class="setting-group" style="font-size: 0.7rem; opacity: 0.7; line-height: 1.3;">
                    <strong>Weight Guide:</strong><br>
                    ‚Ä¢ <strong>Emotional</strong>: Valence/arousal drive mode & key brightness<br>
                    ‚Ä¢ <strong>Semantic</strong>: Word meaning influences scale/chord choices<br>
                    ‚Ä¢ <strong>Phonetic</strong>: Sound color affects voicing & extensions<br>
                    ‚Ä¢ <strong>Syllabic</strong>: Rhythm patterns from word structure<br>
                    ‚Ä¢ <strong>Archetype</strong>: Pre-built phrase patterns boost
                </div>
        </div>
    </div>

    <!-- MAIN WORKSPACE -->
    <div class="workspace">
        <!-- LEFT SIDEBAR: GENERATOR & REFERENCE -->
        <div class="workspace-column left-sidebar">
            <div class="studio-module mod-input">
                <div class="module-header">
                    <span>INPUT::NUMBER_GEN</span>
                    <button class="btn-icon" onclick="document.getElementById('number-generator-container').classList.toggle('collapsed')">[-]</button>
                </div>
                <div class="module-content">
                    <div id="number-generator-container"></div>
                </div>
            </div>

            <div class="studio-module mod-ref">
                <div class="module-header">
                    <span>REF::CIRCLE_OF_FIFTHS</span>
                </div>
                <div class="module-content">
                    <div id="scale-circle-container"></div>
                </div>
            </div>

            <div class="studio-module mod-tool fill-height">
                <div class="module-header">
                    <span>TOOL::CONTAINER_CHORD</span>
                </div>
                <div class="module-content">
                    <div id="container-chord-container"></div>
                </div>
            </div>

            <div class="studio-module mod-tool fill-height">
                <div class="module-header">
                    <span>TOOL::SCALE_RELATIONSHIPS</span>
                </div>
                <div class="module-content">
                    <div id="scale-relationship-container"></div>
                </div>
            </div>
        </div>

        <!-- CENTER STAGE: COMPOSITION -->
        <div class="workspace-column center-stage">
            <!-- Mini Chord Strip (Sticky) -->
            <div id="mini-chord-strip" class="mini-chord-strip" style="position: sticky; top: 0; z-index: 5; margin: 0; padding: 8px 12px; background: rgba(0,0,0,0.9); border-bottom: 1px solid var(--border-light);"></div>

            <div class="studio-module mod-score">
                <div class="module-header">
                    <span>VISUAL::SHEET_MUSIC</span>
                    <button class="btn-icon">[PRINT]</button>
                </div>
                <div class="module-content">
                    <div id="sheet-music-container"></div>
                </div>
            </div>

            <div class="studio-module mod-db">
                <div class="module-header">
                    <span>DB::CHORD_EXPLORER</span>
                    <button class="btn-icon">[OPTS]</button>
                </div>
                <div class="module-content" style="padding: 5px;">
                    <div id="chord-explorer-container"></div>
                </div>
            </div>

            <div class="studio-module mod-prog">
                <div class="module-header">
                    <span>SEQ::PROGRESSION_BUILDER</span>
                </div>
                <div class="module-content" style="padding: 8px;">
                    <div id="progression-builder-container"></div>
                </div>
            </div>
            
            <div class="studio-module mod-solar">
                <div class="module-header">
                    <span>SYS::SOLAR_VISUALIZER</span>
                    <button class="btn-icon" id="dock-solar">[UNDOCK]</button>
                </div>
                <div class="module-content" style="padding: 0; min-height: 300px; position: relative;">
                    <div id="solar-dock-viewport" style="width: 100%; min-height: 300px;"></div>
                    <!-- Hidden sun container for logic -->
                    <div class="sun" style="display: none;"><div id="sun-viewport"></div></div>
                </div>
            </div>
        </div>

        <!-- RIGHT SIDEBAR: TOOLS -->
        <div class="workspace-column right-sidebar">
            <div class="studio-module mod-ref">
                <div class="module-header">
                    <span>REF::GRADING_KEY</span>
                </div>
                <div class="module-content" id="grading-key-sidebar">
                    <!-- Will be populated dynamically -->
                </div>
            </div>

            <div class="studio-module mod-ref">
                <div class="module-header">
                    <span>VISUAL::GUITAR_FRETBOARD</span>
                </div>
                <div class="module-content">
                    <div id="guitar-fretboard-container"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- BOTTOM DECK: PIANO -->
    <div class="bottom-deck">
        <div class="bottom-deck-label">
            <span class="deck-icon">üéπ</span>
            <span class="deck-title">PIANO VISUALIZER</span>
            <span class="deck-status" id="piano-deck-status">READY</span>
        </div>
        <div id="piano-container"></div>
    </div>

    <!-- Hidden/Utility Containers -->
    <div id="mini-piano-visualize-container" style="display: none;"></div>
    <div id="solar-docked-module" class="hidden"></div> <!-- Logic placeholder -->

    <!-- Module Scripts -->
        <style>
            /* Remove leftover mini solar containers */
            #solar-condensed, #solar-under-grading, .solar-condensed { display: none !important; }
            /* Keep grading sidebar compact and scrollable so it doesn't push layout */
            #grading-key-sidebar { max-height: 48vh; overflow: auto; font-size: 0.9rem; }
            #grading-key-sidebar .module-header { font-size: 0.78rem; }
        </style>
    <script src="music-theory-engine.js?v=3"></script>
    <script src="word-database.js"></script>
    
    <!-- NEW: Comprehensive Scale Intelligence System -->
    <script src="scale-intelligence-engine.js"></script>
    
    <!-- NEW: Generative Word-to-Music System -->
    <!-- <script src="phonetic-analyzer.js"></script> -->
    <script src="chord-attribute-engine.js"></script>
    <script src="semantic-api-engine.js"></script>
    <script src="voice-leading-engine.js"></script>
    <!-- <script src="generative-word-mapper.js"></script> -->
    
    <script src="simple-word-engine.js?v=5"></script>
    <script src="sheet-music-generator.js"></script>
    <script src="number-generator.js"></script>
    <script src="scale-library.js"></script>
    <script src="piano-visualizer.js?v=2"></script>
    <script src="guitar-fretboard-visualizer.js"></script>
    <script src="container-chord-tool.js"></script>
    <script src="scale-relationship-explorer.js"></script>
    <script src="progression-builder.js"></script>
    <script src="scale-circle-explorer.js"></script>
    <script src="solar-system-visualizer.v2.js"></script>
    <script src="audio-visualizer.js"></script>
    <script src="unified-chord-explorer.js"></script>
    <!-- <script src="grading-legend-help-system.js"></script> -->
    <!-- <script src="word-grading-visualization.js"></script> -->
    <script src="bitwig-midi.js"></script>

    <script>
        // ==================== CHORD EXPLORER ====================

        class ChordExplorer {
            constructor(musicTheory, scaleLibrary, numberGenerator) {
                this.musicTheory = musicTheory;
                this.scaleLibrary = scaleLibrary;
                this.numberGenerator = numberGenerator;
                this.container = null;
                this.key = this.scaleLibrary.getCurrentKey();
                this.scale = this.scaleLibrary.getCurrentScale();
                this.highlightSet = new Set();
                this.symbolStyle = 'glyphs'; // 'glyphs' | 'jazz' | 'classical'
                this.listeners = new Map(); // Event system

                // Listen to scale changes
                if (this.scaleLibrary && this.scaleLibrary.on) {
                    this.scaleLibrary.on('scaleChanged', (data) => {
                        this.key = data.key;
                        this.scale = data.scale;
                        this.render();
                    });
                }

                // Listen to number changes
                if (this.numberGenerator && this.numberGenerator.on) {
                    this.numberGenerator.on('numbersChanged', (data) => {
                        this.setHighlights(data.numbers, data.type);
                        this.render();
                    });
                }
            }

            formatChordName(root, chordType) {
                const style = this.symbolStyle;
                const type = chordType || '';
                const isHalfDim = /^m7b5$/i.test(type) || /^m\(b5\)$/i.test(type) || /√∏/i.test(type);
                const isDim7 = /^(dim7|o7)$/i.test(type);
                const isDim = /^(dim|o)$/i.test(type);

                if (style === 'glyphs') {
                    if (isHalfDim) return root + '√∏' + (/(7)/.test(type) ? '7' : '');
                    if (isDim7) return root + '¬∞7';
                    if (isDim) return root + '¬∞';
                    return root + type;
                }
                if (style === 'jazz') {
                    // Jazz text conventions
                    if (isHalfDim) return root + 'm7b5';
                    if (isDim7) return root + 'dim7';
                    if (isDim) return root + 'dim';
                    return root + type;
                }
                // Classical text (spelled-out)
                if (isHalfDim) return root + ' half-diminished' + (/(7)/.test(type) ? '7' : '');
                if (isDim7) return root + ' diminished7';
                if (isDim) return root + ' diminished';
                return root + type;
            }

            getDegreeCount() {
                return String(this.scale || '').startsWith('barry_') ? 8 : 7;
            }

            setHighlights(numbers = [], type = 'diatonic') {
                const N = this.getDegreeCount();
                const norm = (n) => ((Number(n) - 1) % N + N) % N + 1;
                this.highlightSet = new Set((numbers || []).map(norm));
            }

            getUsageSuggestions(chord, degree, key, scale) {
                const suggestions = [];
                const rnMap = ['I','II','III','IV','V','VI','VII','VIII'];
                const isMinorQual = /(^m(?!aj))|dim|¬∞|√∏|m7b5/i.test(chord.chordType || '');
                let rn = rnMap[(degree - 1) % rnMap.length];
                if (isMinorQual) rn = rn.toLowerCase();
                try {
                    const scaleNotes = this.musicTheory.getScaleNotes(key, scale);
                    const chordNotes = (chord.diatonicNotes && chord.diatonicNotes.length) ? chord.diatonicNotes : (this.musicTheory.getChordNotes(chord.root, chord.chordType) || []);
                    const analysis = this.musicTheory.findAllContainerChords(chordNotes, scaleNotes) || [];
                    let self = analysis.find(a => a.fullName === chord.root + chord.chordType) || analysis.find(a => a.root === chord.root && a.chordType === chord.chordType) || null;
                    if (self && self.functions && self.functions.length) {
                        const funcs = self.functions.join(', ');
                        const res = self.resolutions && self.resolutions.length ? ` ${self.resolutions.join(', ')}` : '';
                        suggestions.push(`In ${key} ${scale}, this is ${rn} (${funcs}).${res ? ' Typical move:' + res : ''}`);
                    } else {
                        suggestions.push(`In ${key} ${scale}, this is ${rn}.`);
                    }
                } catch(e) {
                    suggestions.push(`In ${key} ${scale}, this is ${rn}.`);
                }
                const type = chord.chordType || '';
                const root = chord.root;
                if (/m7b5/i.test(type)) {
                    const tonicMinor = this.musicTheory.getNoteFromInterval(root, 10);
                    const vRoot = this.musicTheory.getNoteFromInterval(tonicMinor, 7);
                    const iiName = this.formatChordName(root, 'm7b5');
                    const vName = this.formatChordName(vRoot, '7b9');
                    const iName = this.formatChordName(tonicMinor, 'm');
                    suggestions.push(`Minor ii‚ÄìV‚Äìi: ${iiName} ‚Üí ${vName} ‚Üí ${iName}`);
                    suggestions.push(`Scales over ${iiName}: Locrian or Locrian ‚ôÆ2 on ${root}`);
                } else if (/^7($|[^a-zA-Z])/i.test(type)) {
                    const I = this.musicTheory.getNoteFromInterval(root, 5);
                    const vName = this.formatChordName(root, '7');
                    const Imaj = this.formatChordName(I, 'maj');
                    const sub = this.musicTheory.getNoteFromInterval(root, 6);
                    const subName = this.formatChordName(sub, '7');
                    suggestions.push(`Dominant: ${vName} ‚Üí ${Imaj}`);
                    suggestions.push(`Scales on ${root}: Mixolydian, Altered, Half‚ÄìWhole diminished`);
                    suggestions.push(`Tritone sub: ${subName} ‚Üí ${Imaj}`);
                } else if (/maj7/i.test(type)) {
                    const iiRoot = this.musicTheory.getNoteFromInterval(root, 2);
                    const vRoot = this.musicTheory.getNoteFromInterval(root, 7);
                    const iiName = this.formatChordName(iiRoot, 'm7');
                    const vName = this.formatChordName(vRoot, '7');
                    const IName = this.formatChordName(root, 'maj7');
                    suggestions.push(`Major ii‚ÄìV‚ÄìI: ${iiName} ‚Üí ${vName} ‚Üí ${IName}`);
                    suggestions.push(`Scales on ${root}: Ionian, Lydian`);
                } else if (/^m7($|[^a-zA-Z])/i.test(type)) {
                    const I = this.musicTheory.getNoteFromInterval(root, 10);
                    const vRoot = this.musicTheory.getNoteFromInterval(I, 7);
                    const iiName = this.formatChordName(root, 'm7');
                    const vName = this.formatChordName(vRoot, '7');
                    const Imaj = this.formatChordName(I, 'maj7');
                    suggestions.push(`As ii in major: ${iiName} ‚Üí ${vName} ‚Üí ${Imaj}`);
                    suggestions.push(`Scale on ${root}: Dorian`);
                } else if (/dim7/i.test(type)) {
                    const I = this.musicTheory.getNoteFromInterval(root, 1);
                    const vii = this.formatChordName(root, 'dim7');
                    const Imaj = this.formatChordName(I, 'maj');
                    suggestions.push(`Leading-tone: ${vii} ‚Üí ${Imaj}`);
                    suggestions.push(`Scale on ${root}: Diminished (whole‚Äìhalf)`);
                } else if (/mMaj7/i.test(type)) {
                    const iName = this.formatChordName(root, 'mMaj7');
                    suggestions.push(`Minor tonic color: ${iName}`);
                    suggestions.push(`Scale on ${root}: Melodic minor`);
                }
                return suggestions;
            }

            mount(container) {
                if (typeof container === 'string') {
                    container = document.querySelector(container);
                }
                if (!container) return;
                this.container = container;
                // Initialize highlights from current generator state
                if (this.numberGenerator) {
                    this.setHighlights(
                        this.numberGenerator.getCurrentNumbers(),
                        this.numberGenerator.getNumberType()
                    );
                }
                this.render();
            }

            render() {
                if (!this.container) return;
                const N = this.getDegreeCount();
                const key = this.key;
                const scale = this.scale;

                const cards = [];
                for (let degree = 1; degree <= N; degree++) {
                    const chord = this.musicTheory.getDiatonicChord(degree, key, scale);
                    let notes = [];
                    try {
                        notes = (chord.diatonicNotes && chord.diatonicNotes.length)
                            ? chord.diatonicNotes
                            : (this.musicTheory.getChordNotes(chord.root, chord.chordType) || []);
                    } catch (e) {
                        notes = [];
                    }
                    const romanNumerals = ['I','II','III','IV','V','VI','VII','VIII'];
                    const isMinorQuality = /(^m(?!aj))|dim|¬∞|√∏|m7b5/i.test(chord.chordType || '');
                    let rn = romanNumerals[(degree - 1) % romanNumerals.length];
                    if (isMinorQuality) rn = rn.toLowerCase();
                    const selected = this.highlightSet.has(degree) ? 'selected' : '';
                    const displayName = this.formatChordName(chord.root, chord.chordType);
                    cards.push(`
                        <div class="chord-card ${selected}" data-degree="${degree}">
                            <div class="chord-name">${displayName}</div>
                            <div class="chord-notes">${notes.join(' ')}</div>
                            <div class="chord-meta"><span>${rn}</span></div>
                        </div>
                    `);
                }

                this.container.innerHTML = `
                    <div class="chord-explorer-ui">
                        <div class="symbol-toggle" aria-label="Chord symbol style">
                            <button type="button" class="${this.symbolStyle === 'glyphs' ? 'active' : ''}" data-style="glyphs">Glyphs</button>
                            <button type="button" class="${this.symbolStyle === 'jazz' ? 'active' : ''}" data-style="jazz">Jazz</button>
                            <button type="button" class="${this.symbolStyle === 'classical' ? 'active' : ''}" data-style="classical">Classical</button>
                        </div>
                        <div class="chord-grid">
                            ${cards.join('')}
                        </div>
                        <div class="chord-usage-panel" id="chord-usage-panel"></div>
                    </div>
                `;

                // Wire up toggle buttons
                const toggle = this.container.querySelector('.symbol-toggle');
                if (toggle) {
                    toggle.querySelectorAll('button[data-style]').forEach(btn => {
                        btn.addEventListener('click', () => {
                            const style = btn.getAttribute('data-style');
                            if (style && (style === 'glyphs' || style === 'jazz' || style === 'classical')) {
                                this.symbolStyle = style;
                                this.render();
                            }
                        });
                    });
                }

                const cardsEls = this.container.querySelectorAll('.chord-card');
                cardsEls.forEach(card => {
                    card.addEventListener('click', () => {
                        const degree = Number(card.getAttribute('data-degree')) || 1;
                        const chord = this.musicTheory.getDiatonicChord(degree, this.key, this.scale);
                        const usage = this.getUsageSuggestions(chord, degree, this.key, this.scale);
                        const panel = this.container.querySelector('#chord-usage-panel');
                        if (panel) {
                            const displayName = this.formatChordName(chord.root, chord.chordType);
                            panel.innerHTML = `
                                <div class="chord-usage-title">Usage ideas for ${displayName} (${this.key} ${this.scale})</div>
                                <ul class="chord-usage-list">
                                    ${usage.map(u => `<li>${u}</li>`).join('')}
                                </ul>
                            `;
                        }
                        this.container.querySelectorAll('.chord-card').forEach(el=>el.classList.remove('selected'));
                        card.classList.add('selected');
                        
                        // Add chordNotes to the chord object for sheet music rendering
                        const chordWithNotes = {
                            ...chord,
                            chordNotes: this.musicTheory.getChordNotes(chord.root, chord.chordType) || []
                        };
                        
                        // Emit chordSelected event for other modules, include degree for linking
                        // Log explorer selection for diagnostics
                        try {
                            if (!window.__interactionLog) window.__interactionLog = [];
                            window.__interactionLog.push({
                                type: 'chordExplorerChordSelected',
                                details: { degree, chord: { root: chordWithNotes.root, chordType: chordWithNotes.chordType, chordNotes: chordWithNotes.chordNotes } },
                                timestamp: new Date().toISOString()
                            });
                        } catch (_) {}

                        this.emit('chordSelected', { chord: chordWithNotes, degree });
                    });
                });

                // When manual roman/chord input is finalized, append committed chords to sheet (like insert-plus)
                this.numberGenerator.on('displayTokensCommitted', (evt) => {
                    try {
                        console.log('[ModularMusicTheoryApp] displayTokensCommitted received ->', evt);
                        const rawTokens = evt && evt.rawTokens ? evt.rawTokens : (evt && evt.tokens ? evt.tokens : null);
                        const tokens = evt && evt.tokens ? evt.tokens : null;
                        if (!tokens || !Array.isArray(tokens) || tokens.length === 0) return;

                        // Build chord objects and append each to the sheet generator
                        tokens.forEach((tok, idx) => {
                            const rawTok = (rawTokens && rawTokens[idx]) ? rawTokens[idx] : tok;
                            try {
                                const normalized = (this.numberGenerator && typeof this.numberGenerator.normalizePreviewRomanToken === 'function')
                                    ? this.numberGenerator.normalizePreviewRomanToken(tok)
                                    : tok;

                                // Debug: log token transformation details to help trace mutation issues
                                console.log('[ModularMusicTheoryApp] commit-token ->', { idx, rawTok, tok, normalized });

                                let chordObj = null;
                                // If the normalized token looks like a spelled-root label (e.g. 'F', 'Fm', 'Fmaj7'), prefer that
                                const normalizedSpelled = String(normalized).match(/^([A-G][b#]?)(.*)$/i);
                                if (normalizedSpelled) {
                                    const root = normalizedSpelled[1];
                                    const chordType = (normalizedSpelled[2] || '').trim();
                                    let chordNotes = [];
                                    try { chordNotes = this.musicTheory.getChordNotes(root, chordType) || []; } catch(_) { chordNotes = []; }
                                    if (chordNotes.length > 0) {
                                        chordObj = { root, chordType, chordNotes, fullName: (root || '') + (chordType || '') };
                                        console.log('[ModularMusicTheoryApp] parsed-as-spelled(normalized) ->', { idx, root, chordType, chordObj, rawTok, normalized });
                                    }
                                }
                                // If spelled-root parsing failed, try Roman numeral parsing (use rawTok for roman detection)
                                if (!chordObj) {
                                    const romanMatch = String(rawTok).match(/([#b]?)([IViv]+)(.*)$/);
                                    console.log('[ModularMusicTheoryApp] romanMatch ->', { idx, rawTok, romanMatch, normalized });
                                    if (romanMatch) {
                                        const roman = romanMatch[2];
                                        const suffix = (romanMatch[3] || '').trim();
                                        const rawHasHalfDim = /√∏|m7b5|half[-]?dim/i.test(rawTok);
                                        const rawHasDim = /¬∞|dim(?!.*maj)/i.test(rawTok);
                                        const romanToInt = (r) => {
                                            const s = String(r).toUpperCase();
                                            const map = { 'I':1,'II':2,'III':3,'IV':4,'V':5,'VI':6,'VII':7 };
                                            return map[s] || null;
                                        };
                                        const degree = romanToInt(roman);
                                        if (degree) {
                                            const key = this.scaleLibrary.getCurrentKey();
                                            const scale = this.scaleLibrary.getCurrentScale();
                                            try {
                                                const diat = this.musicTheory.getDiatonicChord(degree, key, scale);
                                                if (diat) {
                                                    // Respect Roman case: lowercase = minor, uppercase = major
                                                    const isLower = roman === roman.toLowerCase();
                                                    // Determine preferred chord type when the user provided no explicit suffix.
                                                    // Prefer a simple triad for a bare Roman numeral (IV -> maj triad),
                                                    // unless the user explicitly typed an extension/suffix.
                                                    let baseType = '';
                                                    if (rawHasHalfDim) {
                                                        baseType = 'm7b5';
                                                    } else if (rawHasDim) {
                                                        baseType = 'dim7';
                                                    } else if (suffix) {
                                                        baseType = suffix;
                                                    } else if (isLower) {
                                                        baseType = 'm';
                                                    } else {
                                                        // No suffix and uppercase Roman: prefer triad quality (maj) instead of a 7th
                                                        try {
                                                            const triad = this.musicTheory.buildScaleChord(key, scale, degree, 3);
                                                            const triadType = this.musicTheory.classifyChordTypeFromNotes(diat.root, triad.notes) || '';
                                                            baseType = triadType || diat.chordType;
                                                        } catch (_) {
                                                            baseType = diat.chordType;
                                                        }
                                                    }

                                                    let notes = [];
                                                    try {
                                                        if (this.musicTheory && typeof this.musicTheory.getChordNotes === 'function') {
                                                            notes = this.musicTheory.getChordNotes(diat.root, baseType) || [];
                                                            if ((!notes || notes.length === 0) && baseType !== diat.chordType) {
                                                                notes = this.musicTheory.getChordNotes(diat.root, diat.chordType) || [];
                                                            }
                                                        }
                                                    } catch(_) { notes = [] }
                                                    chordObj = { root: diat.root, chordType: baseType || diat.chordType, chordNotes: notes, fullName: (diat.root || '') + (baseType || diat.chordType || '') };
                                                    console.log('[ModularMusicTheoryApp] parsed-as-diatonic ->', { idx, degree, diat, baseType, chordObj });
                                                }
                                            } catch(e) { console.warn('[ModularMusicTheoryApp] diatonic-parse-error', { idx, e }); }
                                        }
                                    }
                                }
                                // If still no chordObj, try to parse as a chord label using music theory engine
                                if (!chordObj && this.musicTheory && typeof this.musicTheory.parseChordLabel === 'function') {
                                    try {
                                        const parsed = this.musicTheory.parseChordLabel(rawTok);
                                        if (parsed && parsed.root && parsed.chordType) {
                                            let notes = this.musicTheory.getChordNotes(parsed.root, parsed.chordType) || [];
                                            chordObj = { root: parsed.root, chordType: parsed.chordType, chordNotes: notes, fullName: (parsed.root || '') + (parsed.chordType || '') };
                                            console.log('[ModularMusicTheoryApp] parsed-as-label ->', { idx, parsed, chordObj });
                                        }
                                    } catch(e) { console.warn('[ModularMusicTheoryApp] label-parse-error', { idx, e }); }
                                }

                                if (chordObj && this.sheetMusicGenerator && typeof this.sheetMusicGenerator.setCurrentChord === 'function') {
                                    // Debug: final chord object before appending
                                    console.log('[ModularMusicTheoryApp] appending-chord ->', { idx, chordObj });
                                    try {
                                            // Log the parsed chord object before canonicalization
                                            try {
                                                if (!window.__interactionLog) window.__interactionLog = [];
                                                window.__interactionLog.push({
                                                    type: 'displayTokensCommitParsed',
                                                    details: { idx, rawTok, tok, normalized, parsed: chordObj },
                                                    timestamp: new Date().toISOString()
                                                });
                                            } catch (_) {}

                                            // Defensive fallback: if chordNotes are empty, try canonicalizing chordType symbols
                                            if ((!chordObj.chordNotes || chordObj.chordNotes.length === 0) && chordObj.chordType) {
                                                const mapType = (t) => {
                                                    if (!t) return t;
                                                    let s = String(t);
                                                    // Map symbol forms to canonical names
                                                    if (/(¬∞|dim(?!.*maj))/i.test(s)) return 'dim7';
                                                    if (/(√∏|m7b5|half-?dim)/i.test(s)) return 'm7b5';
                                                    // common short forms
                                                    if (/^m7b5$/i.test(s)) return 'm7b5';
                                                    if (/^dim7$/i.test(s)) return 'dim7';
                                                    return s;
                                                };
                                                const canonical = mapType(chordObj.chordType);
                                                if (canonical !== chordObj.chordType) {
                                                    try {
                                                        const notes = this.musicTheory.getChordNotes(chordObj.root, canonical) || [];
                                                        if (notes && notes.length) {
                                                            chordObj = { ...chordObj, chordType: canonical, chordNotes: notes, fullName: (chordObj.root || '') + (canonical || '') };
                                                            try {
                                                                window.__interactionLog.push({ type: 'displayTokensCommitCanonicalized', details: { idx, canonical, chordObj }, timestamp: new Date().toISOString() });
                                                            } catch(_){}
                                                        }
                                                    } catch(_) {}
                                                }
                                            }

                                            this.sheetMusicGenerator.setCurrentChord(chordObj, { appendToBars: true });
                                        // Log chord commit and sheet music state
                                        if (window.logChordCommit) window.logChordCommit({
                                            input: tok,
                                            raw: rawTok,
                                            normalized,
                                            chordObj,
                                            idx,
                                            sheetMusic: this.sheetMusicGenerator.getCurrentSheet ? this.sheetMusicGenerator.getCurrentSheet() : null
                                        });
                                        if (window.logSheetMusicUpdate) window.logSheetMusicUpdate({
                                            chords: this.sheetMusicGenerator.getCurrentSheet ? this.sheetMusicGenerator.getCurrentSheet() : null,
                                            lastChord: chordObj,
                                            idx
                                        });
                                    } catch(e) { console.warn('[ModularMusicTheoryApp] setCurrentChord failed', { idx, e }); }
                                } else {
                                    console.log('[ModularMusicTheoryApp] no-chord-created-for-token', { idx, rawTok, tok, normalized });
                                }
                            } catch (e) { console.warn('[ModularMusicTheoryApp] per-token-exception', { idx, e }); }
                });
            } catch (e) {
                console.warn('Failed to append committed display tokens to sheet:', e);
            }
        });
            }

            // Event system methods
            on(event, callback) {
                if (!this.listeners.has(event)) {
                    this.listeners.set(event, new Set());
                }
                this.listeners.get(event).add(callback);
            }

            off(event, callback) {
                if (this.listeners.has(event)) {
                    this.listeners.get(event).delete(callback);
                }
            }

            emit(event, data) {
                if (this.listeners.has(event)) {
                    this.listeners.get(event).forEach(callback => {
                        try {
                            callback(data);
                        } catch (error) {
                            console.error('Error in ChordExplorer event listener:', error);
                        }
                    });
                }
            }
        }

        // ==================== AUDIO ENGINE ====================
        class SimpleAudioEngine {
            constructor() {
                this.ctx = null;
                this.masterGain = null;
            }

            init() {
                if (this.ctx) return;
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.3;
                this.masterGain.connect(this.ctx.destination);
            }

            resume() {
                if (!this.ctx) this.init();
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            }

            playNote(midi, duration = 0.5, time = 0) {
                this.resume();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'triangle';
                osc.frequency.value = 440 * Math.pow(2, (midi - 69) / 12);
                
                osc.connect(gain);
                gain.connect(this.masterGain);
                
                const now = this.ctx.currentTime + time;
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(1, now + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
                
                osc.start(now);
                osc.stop(now + duration + 0.1);
            }

            playChord(notes, duration = 1.0) {
                this.resume();
                notes.forEach(note => {
                    let midi = note;
                    if (typeof note === 'string') {
                        midi = this.noteToMidi(note);
                    }
                    if (midi) this.playNote(midi, duration);
                });
            }

            noteToMidi(noteName) {
                const NOTE_TO_SEMITONE = {
                    'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3, 'E': 4,
                    'F': 5, 'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8, 'Ab': 8,
                    'A': 9, 'A#': 10, 'Bb': 10, 'B': 11
                };
                const match = String(noteName).match(/^([A-G][#b]?)(-?\d+)$/);
                if (!match) return null;
                const semitone = NOTE_TO_SEMITONE[match[1]];
                const octave = parseInt(match[2]);
                return (octave + 1) * 12 + semitone;
            }
        }

        // ==================== MODULAR APPLICATION ====================
        // Lightweight fallback for grading legend help system
        // If the full `GradingLegendHelpSystem` implementation isn't present,
        // this stub will render the grading legend into any host elements
        // and subscribe to the music theory engine for updates.
        class GradingLegendHelpSystem {
            constructor(musicTheory) {
                this.musicTheory = musicTheory;
                try { this.renderAll(); } catch(_) {}
                // Subscribe to changes if possible
                if (this.musicTheory && typeof this.musicTheory.subscribe === 'function') {
                    this.musicTheory.subscribe((ev) => {
                        try { this.renderAll(); } catch(_) {}
                    });
                }
            }

            getLegendItems() {
                if (!this.musicTheory || typeof this.musicTheory.getGradingTierInfo !== 'function') return [];
                const tiers = [4,3,2,1,0];
                return tiers.map(t => this.musicTheory.getGradingTierInfo(t) || null).filter(Boolean);
            }

            renderInto(host) {
                if (!host) return;
                const items = this.getLegendItems();
                if (!items.length) return;
                const html = items.map(info => `
                    <div style="margin-bottom:12px;">
                        <div style="display:flex; align-items:center; gap:6px; margin-bottom:4px;">
                            <div style="width:16px; height:16px; background:${info.color}; border-radius:3px; flex-shrink:0;"></div>
                            <span style="color:${info.color}; font-weight:bold; font-size:0.9rem;">${info.short} ${info.name}</span>
                        </div>
                        <div style="font-size:0.75rem; opacity:0.7; margin-left:22px;">${info.desc}</div>
                    </div>
                `).join('');
                host.innerHTML = `<div style="padding:10px;"><div style="margin-bottom:10px; font-weight:600; text-transform:uppercase; letter-spacing:0.04em; font-size:0.68rem; color:var(--text-secondary);">Chord Grading</div>${html}</div>`;
            }

            renderAll() {
                // Legend element inside main UI
                const legend = document.getElementById('grading-key-legend');
                if (legend) this.renderInto(legend);
                // Sidebar fallback
                const sidebar = document.getElementById('grading-key-sidebar');
                if (sidebar) this.renderInto(sidebar);
            }
        }

        class ModularMusicTheoryApp {
            constructor() {
                this.audioEngine = new SimpleAudioEngine();
                this.musicTheory = new MusicTheoryEngine();
                this.numberGenerator = new NumberGenerator();
                this.numberGenerator.connectMusicTheory(this.musicTheory); // Connect for intelligent generation
                this.scaleLibrary = new ScaleLibrary(this.musicTheory);
                this.pianoVisualizer = new PianoVisualizer({
                    startMidi: 21,
                    octaves: 7,
                    whiteKeyWidth: 30,
                    whiteKeyHeight: 120,
                    blackKeyHeight: 80,
                    showFingering: true,
                    showRomanNumerals: true,
                    fitToContainer: false
                });
                this.guitarFretboard = new GuitarFretboardVisualizer({ frets: 22, showNoteLabels: true });
                this.containerChordTool = new ContainerChordTool(this.musicTheory);
                this.scaleRelationshipExplorer = new ScaleRelationshipExplorer(this.musicTheory);
                this.progressionBuilder = new ProgressionBuilder(this.musicTheory);
                this.scaleCircleExplorer = new ScaleCircleExplorer(this.musicTheory);
                this.solarSystem = new SolarSystemVisualizer(this.musicTheory);
                this.audioVisualizer = new AudioVisualizer();
                // Use UnifiedChordExplorer (new consolidated explorer). Keep tools wired to it.
                try {
                    this.chordExplorer = new UnifiedChordExplorer(this.musicTheory);
                    // Wire number generator for progression highlighting and preferred notes
                    if (typeof this.chordExplorer.connectNumberGenerator === 'function') {
                        this.chordExplorer.connectNumberGenerator(this.numberGenerator);
                    }
                    // Wire scale library so explorer updates when key/scale change
                    if (typeof this.chordExplorer.connectScaleLibrary === 'function') {
                        this.chordExplorer.connectScaleLibrary(this.scaleLibrary);
                    }
                    // Initialize with current key/scale
                    if (typeof this.chordExplorer.setKeyAndScale === 'function') {
                        this.chordExplorer.setKeyAndScale(this.scaleLibrary.getCurrentKey(), this.scaleLibrary.getCurrentScale());
                    }
                    // Expose legacy mount compatibility if needed (UnifiedChordExplorer provides mount)
                } catch (e) {
                    // Fallback to original explorer if UnifiedChordExplorer missing
                    console.warn('UnifiedChordExplorer not available, falling back to legacy ChordExplorer', e);
                    this.chordExplorer = new ChordExplorer(this.musicTheory, this.scaleLibrary, this.numberGenerator);
                }
                this.sheetMusicGenerator = new SheetMusicGenerator(this.musicTheory);

                // Initialize grading legend and help system
                try {
                    this.gradingHelpSystem = new GradingLegendHelpSystem(this.musicTheory);
                } catch (e) {
                    console.warn('GradingLegendHelpSystem not available:', e);
                }

                // Initialize word grading visualization system
                try {
                    // Wait for word engine to be available
                    setTimeout(() => {
                        if (typeof window.wordEngine !== 'undefined' && window.wordEngine) {
                            this.wordGradingViz = new WordGradingVisualization(this.musicTheory, window.wordEngine);
                            window.wordGradingViz = this.wordGradingViz; // Make globally available
                        }
                    }, 1000);
                } catch (e) {
                    console.warn('WordGradingVisualization not available:', e);
                }

                this.initialize();
            }

            initialize() {
                this.setupModuleIntegration();
                this.setupEventHandlers();
                this.renderInitialState();
                // Initial mini chord strip render
                try { this.renderMiniChordStrip(this.scaleLibrary.getCurrentKey(), this.scaleLibrary.getCurrentScale()); } catch(_){}
                // Setup sticky scroll behavior for mini chord strip
                try { this.setupMiniStripScrollBehavior(); } catch(e){ console.warn('Sticky mini strip setup failed', e); }
                // Debug helper: quick test to validate roman input mapping across modules.
                // Usage (in browser console): window.modularApp.selfTestRomanInputs('vii√∏7 ii7 IVmaj7 iii7 ')
                this.selfTestRomanInputs = (inputStr) => {
                    try {
                        if (!inputStr || !this.numberGenerator) return null;
                        const trimmed = String(inputStr || '').trim();
                        const toks = trimmed.length ? trimmed.split(/\s+/).filter(t => t.length) : [];
                        // Preview first
                        try { this.numberGenerator.setDisplayTokens(toks, { rawTokens: toks.slice(), emit: true }); } catch(_){ }
                        // Commit via manualInput element if present (will append to sheet)
                        const inputEl = document.querySelector('#manual-numbers');
                        if (inputEl) {
                            inputEl.value = inputStr;
                            try { this.numberGenerator.commitManualNumbers(inputEl, { force: true }); } catch(e) { console.warn(e); }
                        } else {
                            // fallback: emit displayTokensCommitted directly
                            try { this.numberGenerator.emit('displayTokensCommitted', { tokens: toks, rawTokens: toks }); } catch(_) {}
                        }
                        // After commit, return last appended chords types
                        try { return (this.sheetMusicGenerator && Array.isArray(this.sheetMusicGenerator.state.barChords)) ? this.sheetMusicGenerator.state.barChords.map(c => c.chordType) : null; } catch(_) { return null; }
                    } catch (e) { console.warn('selfTestRomanInputs failed', e); return null; }
                };
            }

            /**
             * Render the mini chord strip across the top with Roman numerals for the current key/scale.
             * Uppercase for major quality; lowercase for minor and diminished; use ¬∞ and √∏ where applicable.
             */
            renderMiniChordStrip(key, scale) {
                try {
                    const host = document.getElementById('mini-chord-strip');
                    if (!host) return;
                    const roman = ['I','II','III','IV','V','VI','VII','VIII'];
                    const isBarry = String(scale || '').toLowerCase().startsWith('barry_');
                    const degreeCount = isBarry ? 8 : 7;
                    const scaleName = String(scale || '').toLowerCase();
                    const isMajorish = /major|ionian/.test(scaleName);
                    const isMinorish = /minor|aeolian/.test(scaleName);
                    // Default mapping arrays for diatonic 7ths (descriptive forms)
                    const major7ths = ['maj7','m7','m7','maj7','7','m7','m7b5'];
                    const minor7ths = ['m7','m7b5','maj7','m7','m7','maj7','7'];
                    const items = [];
                    for (let degree = 1; degree <= degreeCount; degree++) {
                        let chord = null;
                        try { chord = this.musicTheory.getDiatonicChord(degree, key, scale) || {}; } catch(_) { chord = {}; }
                        const type = (chord.chordType || '').toLowerCase();
                        const isHalfDim = /m7b5|√∏/.test(type);
                        const isDim = /dim|¬∞/.test(type) && !isHalfDim;
                        const isMinor = /^m(?!aj)/.test(type) && !isHalfDim; // plain minor qualities
                        let label = roman[(degree - 1) % roman.length];
                        let cls = 'maj';
                        if (isHalfDim) { label = label.toLowerCase() + '√∏'; cls = 'dim'; }
                        else if (isDim) { label = label.toLowerCase() + '¬∞'; cls = 'dim'; }
                        else if (isMinor) { label = label.toLowerCase(); cls = 'min'; }
                        // Build 7th chord name (prefer explicit chordType and map to descriptive labels)
                        let seventh = '';
                        if (isMajorish) {
                            seventh = major7ths[(degree - 1) % major7ths.length];
                        } else if (isMinorish) {
                            seventh = minor7ths[(degree - 1) % minor7ths.length];
                        } else {
                            // Fallback from chordType: prefer explicit chord.chordType when present,
                            // and prioritize descriptive forms for aug and half-dim.
                            const ct = chord.chordType || '';
                            if (/m7b5|√∏/.test(ct) || isHalfDim) seventh = 'halfdim7';
                            else if (/dim7|¬∞/.test(ct) || isDim) seventh = 'dim7';
                            else if (/m7#5/.test(ct)) seventh = 'aug(min7)';
                            else if (/maj7#5/.test(ct) || /\+maj7/.test(ct)) seventh = 'aug(maj7)';
                            else if (/mMaj7/i.test(ct)) seventh = 'mMaj7';
                            else if (/maj7/i.test(ct) || /maj7/i.test(type)) seventh = 'maj7';
                            else if (/m7(?!b5)/i.test(ct) || isMinor) seventh = 'm7';
                            else if (/7(?![a-zA-Z])/i.test(ct) || /7(?![a-zA-Z])/i.test(type)) seventh = '7';
                            else seventh = ct || '7';
                        }
                        // Prefer the explicit chord.chordType when available to preserve modifiers
                        const chordName = (chord.root || '') + ((chord.chordType && chord.chordType.length) ? chord.chordType : seventh);
                        items.push(`<div class=\"mini-chord-item ${cls}\" data-degree=\"${degree}\" title=\"Degree ${degree}\"><div class=\"mini-rn\">${label}</div><div class=\"mini-name\">${chordName}</div></div>`);
                    }
                    host.innerHTML = items.join('');
                } catch (e) { /* noop */ }
            }

            /**
             * Keep mini chord strip visible (fixed) until chord explorer module scrolls into view.
             * Removes sticky when chord explorer top edge is near/above viewport top to avoid overlay.
             */
            setupMiniStripScrollBehavior() {
                const strip = document.getElementById('mini-chord-strip');
                const chordModule = document.querySelector('.planet-module[data-module="chord"]');
                if (!strip || !chordModule) return;

                // Spacer to prevent layout shift when strip becomes fixed
                let spacer = document.getElementById('mini-chord-strip-spacer');
                if (!spacer) {
                    spacer = document.createElement('div');
                    spacer.id = 'mini-chord-strip-spacer';
                    spacer.style.height = strip.offsetHeight + 'px';
                    spacer.style.gridColumn = '1 / -1';
                    strip.parentNode.insertBefore(spacer, strip.nextSibling);
                }

                // Make the mini chord strip persistently visible (always sticky)
                // Keep the spacer to prevent layout shift, but avoid dynamic un-sticking.
                if (!strip.classList.contains('sticky')) strip.classList.add('sticky');
                // Ensure spacer height stays correct on resize
                window.addEventListener('resize', () => {
                    spacer.style.height = strip.offsetHeight + 'px';
                });
            }

            setupModuleIntegration() {
                // Connect number generator to container chord tool
                this.numberGenerator.on('numbersChanged', (data) => {
                    const scaleNotes = this.scaleLibrary.getCurrentScaleNotes();
                    const preferred = data.numbers.map(num => {
                        if (typeof num === 'number') {
                            return { note: scaleNotes[(num - 1) % scaleNotes.length], degree: num };
                        }
                        return { note: num, degree: null };
                    });
                    // Use generated notes to bias sorting (single-note mode for selection)
                    this.containerChordTool.setPreferredNotes(preferred);
                    
                    // NOTE: do NOT auto-select generated notes as input by default.
                    // We only want the generated notes to bias sorting (preferredNotes).
                    // Automatically selecting them caused every generated note to be highlighted,
                    // which is not desirable. Clear any selection so nothing is highlighted.
                    // If a developer wants automatic selection later, call setInputNotes explicitly.
                    if (this.containerChordTool && typeof this.containerChordTool.setSelectedNote === 'function') {
                        this.containerChordTool.setSelectedNote('');
                    }
                    

                });

                // Connect scale library to other modules
                this.scaleLibrary.on('scaleChanged', (data) => {
                    const currentNumbers = this.numberGenerator.getCurrentNumbers();
                    if (currentNumbers.length > 0) {
                        this.numberGenerator.emit('numbersChanged', {
                            numbers: currentNumbers,
                            type: this.numberGenerator.getNumberType(),
                            source: 'scale_change'
                        });
                    }

                    // Update progression builder with new key/scale context
                    if (this.progressionBuilder && this.progressionBuilder.state) {
                        this.progressionBuilder.state.currentKey = data.key;
                        this.progressionBuilder.state.currentScale = data.scale;
                    }

                    // Keep container chord tool in sync with key/scale context
                    if (this.containerChordTool && this.containerChordTool.setKeyAndScale) {
                        this.containerChordTool.setKeyAndScale(data.key, data.scale);
                    }

                    this.pianoVisualizer.renderScale(data);
                    this.scaleCircleExplorer.setKey(data.key);
                    this.scaleCircleExplorer.setScaleNotes(data.notes);
                    if (this.sheetMusicGenerator && this.sheetMusicGenerator.setKeyAndScale) {
                        this.sheetMusicGenerator.setKeyAndScale(data.key, data.scale, data.notes);
                    }
                    this.numberGenerator.setCurrentScaleNotes(data.notes);
                    this.numberGenerator.setScaleInfo(data.key, data.scale);
                    this.numberGenerator.render();
                    if (this.solarSystem) {
                        this.solarSystem.updateSystem({ key: data.key, scale: data.scale, notes: data.notes });
                    }
                    const miniPianoContainer = document.getElementById('mini-piano-visualize-container');
                    if (miniPianoContainer) {
                        miniPianoContainer.innerHTML = this.numberGenerator.renderMiniPiano();
                    }
                    // Update citation display
                    const compactInfoContainer = document.getElementById('piano-scale-info-compact');
                    const expandedInfoContainer = document.getElementById('piano-scale-info');
                    
                    if (compactInfoContainer && expandedInfoContainer) {
                        renderScaleCitation(data.scale, compactInfoContainer, expandedInfoContainer);
                    }
                    // Update mini chord strip to reflect new key/scale
                    try { this.renderMiniChordStrip(data.key, data.scale); } catch(_){}
                });

                // Connect container chord tool to piano visualizer
                this.containerChordTool.on('chordSelected', (data) => {
                    const roles = this.containerChordTool.getNoteRoles(
                        data.chord.chordNotes,
                        data.chord.root
                    );
                    this.pianoVisualizer.renderChord({
                        notes: data.chord.chordNotes,
                        roles: Object.entries(roles).map(([note, role]) => ({
                            note,
                            class: role.replace(/\s+/g, '-')
                        }))
                    });
                });

                // Connect progression builder to Solar System to highlight chosen/substituted chords
                if (this.progressionBuilder && this.progressionBuilder.on) {
                    this.progressionBuilder.on('progressionChanged', (data) => {
                        if (this.solarSystem && typeof this.solarSystem.setChordHighlights === 'function') {
                            this.solarSystem.setChordHighlights(data.meta || []);
                        }

                        // Also map progression output into the Sheet Music Generator so the
                        // generated chord sequence is displayed as one chord per bar.
                        try {
                            const meta = data.meta || [];
                            if (this.sheetMusicGenerator && typeof this.sheetMusicGenerator.setBarMode === 'function' && Array.isArray(meta) && meta.length > 0 && this.sheetMusicGenerator.state && this.sheetMusicGenerator.state.followGenerated) {
                                const chords = meta.map((m) => {
                                    const root = m && m.chordRoot ? m.chordRoot : null;
                                    const chordType = m && m.chordType ? m.chordType : '';
                                    const fullName = m && m.fullName ? m.fullName : ((root || '') + (chordType || ''));
                                    // Prefer diatonicNotes from metadata (scale-based stacking)
                                    let chordNotes = [];
                                    let diatonicNotes = null;
                                    if (m && Array.isArray(m.diatonicNotes) && m.diatonicNotes.length > 0) {
                                        diatonicNotes = m.diatonicNotes;
                                        chordNotes = m.diatonicNotes; // Use as fallback for filtering
                                    }
                                    // Try formula-based notes as secondary option
                                    if (!chordNotes.length) {
                                        try {
                                            if (root && this.musicTheory && typeof this.musicTheory.getChordNotes === 'function') {
                                                chordNotes = this.musicTheory.getChordNotes(root, chordType) || [];
                                            }
                                        } catch (e) { /* ignore */ }
                                    }
                                    return {
                                        root,
                                        chordType,
                                        chordNotes,
                                        diatonicNotes,
                                        fullName
                                    };
                                }).filter(c => c.root && (Array.isArray(c.chordNotes) && c.chordNotes.length > 0 || Array.isArray(c.diatonicNotes) && c.diatonicNotes.length > 0));

                                // Parallel degrees array aligned with chords/meta
                                const degrees = meta.map(m => (m && typeof m.degree === 'number') ? m.degree : null);

                                if (chords.length > 0) {
                                    // Replace the bar list and switch into per-bar mode using the public API
                                    if (this.sheetMusicGenerator && typeof this.sheetMusicGenerator.setBarMode === 'function') {
                                        this.sheetMusicGenerator.setBarMode('per-bar');
                                    }
                                    // Pass harmonization mode to sheet music generator
                                    if (this.sheetMusicGenerator && typeof this.sheetMusicGenerator.setHarmonizationMode === 'function' && this.progressionBuilder) {
                                        const mode = this.progressionBuilder.state.harmonizationMode || 'root';
                                        this.sheetMusicGenerator.setHarmonizationMode(mode);
                                        try {
                                            if (!window.__interactionLog) window.__interactionLog = [];
                                            window.__interactionLog.push({ type: 'sheetHarmonizationModeSet', details: { mode, source: 'progressionChanged' }, timestamp: new Date().toISOString() });
                                        } catch (_) {}
                                    }
                                    if (this.sheetMusicGenerator && typeof this.sheetMusicGenerator.setBarChords === 'function') {
                                        this.sheetMusicGenerator.setBarChords(chords);
                                        if (typeof this.sheetMusicGenerator.setBarDegrees === 'function') {
                                            this.sheetMusicGenerator.setBarDegrees(degrees);
                                        } else {
                                            // Fallback: direct state write if API missing
                                            this.sheetMusicGenerator.state.barDegrees = degrees;
                                            try { this.sheetMusicGenerator.render(); } catch(_){}
                                        }
                                    } else if (this.sheetMusicGenerator) {
                                        // Fallback: direct state write if API missing
                                        this.sheetMusicGenerator.state.barChords = chords;
                                        this.sheetMusicGenerator.state.barDegrees = degrees;
                                        try { this.sheetMusicGenerator.render(); } catch(_){}
                                    }
                                }
                            }
                        } catch (e) {
                            console.error('Error mapping progression to sheet music:', e);
                        }
                    });
                }

                // Connect number generator to circle explorer
                this.numberGenerator.on('numbersChanged', (data) => {
                    const scaleNotes = this.scaleLibrary.getCurrentScaleNotes();
                    this.scaleCircleExplorer.setGeneratedNumbers(data.numbers, scaleNotes);
                    if (this.solarSystem && this.solarSystem.setGeneratedNumbers) {
                        this.solarSystem.setGeneratedNumbers(data.numbers, scaleNotes);
                    }
                });

                // Single bubble click: select note across modules
                this.numberGenerator.on('singleNoteSelected', (data) => {
                    try {
                        const note = data && data.note ? data.note : '';
                        if (note) {
                            this.pianoVisualizer.setActiveNotes([note]);
                            if (this.containerChordTool && this.containerChordTool.setSelectedNote) {
                                this.containerChordTool.setSelectedNote(note);
                            }
                        }
                    } catch (e) { console.error(e); }
                });

                // Propagate manual Roman/chord display tokens into SheetMusicGenerator
                this.numberGenerator.on('displayTokensChanged', (evt) => {
                    try {
                        const rawTokens = evt && evt.rawTokens ? evt.rawTokens : (evt && evt.tokens ? evt.tokens : null);
                        const tokens = evt && evt.tokens ? evt.tokens : null;
                        if (!tokens || !Array.isArray(tokens) || tokens.length === 0) return;

                        // Log propagation of preview/display tokens into sheet mapping
                        try {
                            if (!window.__interactionLog) window.__interactionLog = [];
                            window.__interactionLog.push({
                                type: 'displayTokensPropagation',
                                details: { tokens: tokens.slice(), rawTokens: (rawTokens || tokens).slice(), harmonizationMode: (this.progressionBuilder && this.progressionBuilder.state) ? this.progressionBuilder.state.harmonizationMode : null },
                                timestamp: new Date().toISOString()
                            });
                        } catch(_) {}

                        // Convert tokens into chord objects consumable by SheetMusicGenerator
                        const chords = tokens.map((tok, idx) => {
                            const rawTok = (rawTokens && rawTokens[idx]) ? rawTokens[idx] : tok;
                            try {
                                // First, allow NumberGenerator to normalize preview (may map accidentals to spelled roots)
                                const normalized = (this.numberGenerator && typeof this.numberGenerator.normalizePreviewRomanToken === 'function')
                                    ? this.numberGenerator.normalizePreviewRomanToken(tok)
                                    : tok;

                                // If normalized appears to start with a spelled root (A-G), parse root+type
                                const m = String(normalized).match(/^([A-G][b#]?)(.*)$/i);
                                if (m) {
                                    const root = m[1];
                                    const chordType = (m[2] || '').trim();
                                    let chordNotes = [];
                                    if (this.musicTheory && typeof this.musicTheory.getChordNotes === 'function') {
                                        try { chordNotes = this.musicTheory.getChordNotes(root, chordType) || []; } catch(_) { chordNotes = []; }
                                    }
                                    return { root, chordType, chordNotes, fullName: (root || '') + (chordType || '') };
                                }

                                // Otherwise, try to treat token as a Roman numeral -> diatonic degree
                                const romanMatch = String(rawTok).match(/([#b]?)([IViv]+)(.*)$/);
                                if (romanMatch) {
                                    const accidental = romanMatch[1] || '';
                                    const roman = romanMatch[2] || '';
                                    const suffix = (romanMatch[3] || '').trim();
                                    // Map roman to degree 1..7
                                    const romanToInt = (r) => {
                                        const s = String(r).toUpperCase();
                                        const map = { 'I':1,'II':2,'III':3,'IV':4,'V':5,'VI':6,'VII':7 };
                                        return map[s] || null;
                                    };
                                    const degree = romanToInt(roman);
                                    if (degree && this.scaleLibrary) {
                                        const key = this.scaleLibrary.getCurrentKey();
                                        const scale = this.scaleLibrary.getCurrentScale();
                                        try {
                                            const diat = (this.musicTheory && typeof this.musicTheory.getDiatonicChord === 'function')
                                                ? this.musicTheory.getDiatonicChord(degree, key, scale)
                                                : null;
                                            if (diat) {
                                                // Respect Roman case: lowercase = minor, uppercase = major
                                                const isLower = roman === roman.toLowerCase();
                                                let baseType = '';
                                                if (suffix) {
                                                    // User typed explicit quality/extension: use it directly
                                                    baseType = suffix;
                                                } else {
                                                    // No suffix: infer from case
                                                    if (isLower) {
                                                        baseType = 'm'; // lowercase -> minor
                                                    } else {
                                                        baseType = ''; // uppercase -> major (default)
                                                    }
                                                }

                                                // Try to get chord notes for the combined type
                                                let notes = [];
                                                try {
                                                    if (this.musicTheory && typeof this.musicTheory.getChordNotes === 'function') {
                                                        notes = this.musicTheory.getChordNotes(diat.root, baseType) || [];
                                                        if ((!notes || notes.length === 0) && baseType !== diat.chordType) {
                                                            notes = this.musicTheory.getChordNotes(diat.root, diat.chordType) || [];
                                                        }
                                                    }
                                                } catch (_) { notes = [] }
                                                return { root: diat.root, chordType: baseType || diat.chordType, chordNotes: notes, fullName: (diat.root || '') + (baseType || diat.chordType || '') };
                                            }
                                        } catch (_) {}
                                    }
                                }

                                // Fallback: return null so it will be filtered out
                                return null;
                            } catch (e) { return null; }
                        }).filter(c => c && c.root);

                        if (!chords.length) return;

                        const degrees = chords.map(c => {
                            // Attempt to map root back to diatonic degree if possible
                            try {
                                if (this.scaleLibrary && Array.isArray(this.scaleLibrary.getCurrentScaleNotes())) {
                                    const scaleNotes = this.scaleLibrary.getCurrentScaleNotes();
                                    const idx = scaleNotes.indexOf(c.root);
                                    return idx >= 0 ? idx + 1 : null;
                                }
                            } catch (_) {}
                            return null;
                        });

                        if (this.sheetMusicGenerator && typeof this.sheetMusicGenerator.setBarMode === 'function') {
                            this.sheetMusicGenerator.setBarMode('per-bar');
                        }
                        if (this.sheetMusicGenerator && typeof this.sheetMusicGenerator.setHarmonizationMode === 'function' && this.progressionBuilder) {
                            const mode = this.progressionBuilder.state && this.progressionBuilder.state.harmonizationMode ? this.progressionBuilder.state.harmonizationMode : 'root';
                            this.sheetMusicGenerator.setHarmonizationMode(mode);
                            try {
                                if (!window.__interactionLog) window.__interactionLog = [];
                                window.__interactionLog.push({ type: 'sheetHarmonizationModeSet', details: { mode, source: 'displayTokensChanged' }, timestamp: new Date().toISOString() });
                            } catch (_) {}
                        }
                        if (this.sheetMusicGenerator && typeof this.sheetMusicGenerator.setBarChords === 'function') {
                            this.sheetMusicGenerator.setBarChords(chords);
                            if (typeof this.sheetMusicGenerator.setBarDegrees === 'function') {
                                this.sheetMusicGenerator.setBarDegrees(degrees);
                            } else {
                                this.sheetMusicGenerator.state.barDegrees = degrees;
                                try { this.sheetMusicGenerator.render(); } catch(_) {}
                            }
                        } else {
                            this.sheetMusicGenerator.state.barChords = chords;
                            this.sheetMusicGenerator.state.barDegrees = degrees;
                            try { this.sheetMusicGenerator.render(); } catch(_) {}
                        }
                    } catch (e) {
                        console.warn('Failed to propagate display tokens to sheet music:', e);
                    }
                });

                // Connect circle explorer to progression builder
                this.scaleCircleExplorer.on('progressionGenerated', (data) => {
                    const progression = data.progression.map(key => 
                        `${key}${this.scaleLibrary.getCurrentScale() === 'minor' ? 'm' : ''}maj7`
                    );
                    this.progressionBuilder.buildProgressionFromChords(progression);
                });

                this.scaleCircleExplorer.on('keySelected', (data) => {
                    this.scaleLibrary.setKey(data.key);
                });

                // Connect chord explorer / container chord tool to sheet music
                if (this.chordExplorer && this.chordExplorer.on) {
                    this.chordExplorer.on('chordSelected', (data) => {
                        if (this.sheetMusicGenerator) {
                            this.sheetMusicGenerator.setCurrentChord(data.chord, { appendToBars: true });
                        }
                    });
                    
                    // NEW: Listen for chord substitutions and update sheet music
                    this.chordExplorer.on('substitutionSelected', (data) => {
                        try {
                            if (!data || !data.substitution) return;
                            
                            const sub = data.substitution;
                            const original = data.original;
                            
                            // Build chord object from substitution
                            let chordNotes = [];
                            try {
                                if (sub.notes && Array.isArray(sub.notes)) {
                                    chordNotes = sub.notes;
                                } else if (sub.root && this.musicTheory && typeof this.musicTheory.getChordNotes === 'function') {
                                    chordNotes = this.musicTheory.getChordNotes(sub.root, sub.chordType || '') || [];
                                }
                            } catch (e) { /* ignore */ }
                            
                            const chordObj = {
                                root: sub.root,
                                chordType: sub.chordType || '',
                                chordNotes: chordNotes,
                                fullName: sub.fullName || ((sub.root || '') + (sub.chordType || ''))
                            };
                            
                            // Update sheet music with the substituted chord
                            if (this.sheetMusicGenerator) {
                                // If we're in per-bar mode and following the generated progression,
                                // trigger a full sequence update
                                if (this.sheetMusicGenerator.state.barMode === 'per-bar' && 
                                    this.sheetMusicGenerator.state.followGenerated) {
                                    // Trigger sequence rebuild
                                    if (typeof this.chordExplorer.ensureProgressionSequence === 'function') {
                                        const sequence = this.chordExplorer.ensureProgressionSequence();
                                        this.chordExplorer.emit('progressionSequenceChanged', { sequence });
                                    }
                                } else {
                                    // In single mode, just set the current chord
                                    this.sheetMusicGenerator.setCurrentChord(chordObj, { degree: original ? original.degree : null });
                                }
                            }
                            
                            console.log('[Substitution->Sheet] Updated sheet music:', chordObj.fullName);
                        } catch (e) {
                            console.warn('Failed to update sheet music from substitution:', e);
                        }
                    });
                    
                    // NEW: keep SheetMusicGenerator in sync with sequence edits (plus-left/right insertions)
                    this.chordExplorer.on('progressionSequenceChanged', (evt) => {
                        try {
                            if (!evt || !Array.isArray(evt.sequence)) return;
                            if (!this.sheetMusicGenerator || !this.sheetMusicGenerator.state.followGenerated) return;
                            const seq = evt.sequence;
                            const chords = seq.map(entry => {
                                if (entry.type === 'degree') {
                                    try {
                                        const diat = this.musicTheory.getDiatonicChord(entry.degree, this.scaleLibrary.getCurrentKey(), this.scaleLibrary.getCurrentScale());
                                        if (diat) {
                                            const notes = this.musicTheory.getChordNotes(diat.root, diat.chordType) || [];
                                            return { root: diat.root, chordType: diat.chordType, chordNotes: notes, fullName: diat.root + diat.chordType };
                                        }
                                    } catch(_) {}
                                    return null;
                                } else if (entry.type === 'inserted' && entry.substitution) {
                                    const sub = entry.substitution;
                                    try {
                                        const notes = this.musicTheory.getChordNotes(sub.root, sub.chordType) || (sub.notes || []);
                                        return { root: sub.root, chordType: sub.chordType, chordNotes: notes, fullName: (sub.root || '') + (sub.chordType || '') };
                                    } catch(_) {
                                        return null;
                                    }
                                }
                                return null;
                            }).filter(c => c && c.root && Array.isArray(c.chordNotes));
                            // Degrees align to sequence entries: number for degree entries, null for inserted
                            const degrees = seq.map(entry => (entry.type === 'degree' ? entry.degree : null));
                            if (chords.length) {
                                if (typeof this.sheetMusicGenerator.setBarMode === 'function') {
                                    this.sheetMusicGenerator.setBarMode('per-bar');
                                }
                                // Pass harmonization mode to sheet music generator
                                if (typeof this.sheetMusicGenerator.setHarmonizationMode === 'function' && this.progressionBuilder) {
                                    const mode = this.progressionBuilder.state.harmonizationMode || 'root';
                                    this.sheetMusicGenerator.setHarmonizationMode(mode);
                                }
                                if (typeof this.sheetMusicGenerator.setBarChords === 'function') {
                                    this.sheetMusicGenerator.setBarChords(chords);
                                    if (typeof this.sheetMusicGenerator.setBarDegrees === 'function') {
                                        this.sheetMusicGenerator.setBarDegrees(degrees);
                                    } else {
                                        this.sheetMusicGenerator.state.barDegrees = degrees;
                                        try { this.sheetMusicGenerator.render(); } catch(_) {}
                                    }
                                    try {
                                        // Log harmonization mode when set via progressionSequenceChanged
                                        const mode = this.progressionBuilder && this.progressionBuilder.state ? this.progressionBuilder.state.harmonizationMode : null;
                                        if (!window.__interactionLog) window.__interactionLog = [];
                                        window.__interactionLog.push({ type: 'sheetHarmonizationModeSet', details: { mode, source: 'progressionSequenceChanged' }, timestamp: new Date().toISOString() });
                                    } catch(_) {}
                                } else {
                                    this.sheetMusicGenerator.state.barChords = chords;
                                    this.sheetMusicGenerator.state.barDegrees = degrees;
                                    try { this.sheetMusicGenerator.render(); } catch(_) {}
                                }
                            }
                        } catch (e) {
                            console.warn('SheetMusic sync (progressionSequenceChanged) failed', e);
                        }
                    });
                    // Also respond to explicit passing chord insertion events (redundant but defensive)
                    this.chordExplorer.on('passingChordInserted', (data) => {
                        try {
                            // Trigger a sequence rebuild handler above by emitting a faux progressionSequenceChanged
                            if (this.chordExplorer && typeof this.chordExplorer.ensureProgressionSequence === 'function') {
                                const sequence = this.chordExplorer.ensureProgressionSequence();
                                this.chordExplorer.emit('progressionSequenceChanged', { sequence });
                            }
                        } catch(e) { console.warn('passingChordInserted sync failed', e); }
                    });
                }
                if (this.containerChordTool && this.containerChordTool.on) {
                    this.containerChordTool.on('chordSelected', (data) => {
                        if (this.sheetMusicGenerator) {
                            this.sheetMusicGenerator.setCurrentChord(data.chord, { appendToBars: true });
                        }
                    });
                }

                // Connect progression builder to number generator and scale library
                if (this.progressionBuilder && this.progressionBuilder.connectModules) {
                    this.progressionBuilder.connectModules(this.numberGenerator, this.scaleLibrary);
                }
            }

            /**
             * Public entrypoint invoked by the NumberGenerator "Harmonize" button.
             * Ensures the progression builder and sheet generator honor the requested
             * harmonization mode and regenerates the progression / updates the sheet.
             * @param {string} mode 'melody'|'harmony'|'root'
             */
            harmonizeCurrentSequence(mode) {
                try {
                    const m = mode || (this.progressionBuilder && this.progressionBuilder.state && this.progressionBuilder.state.harmonizationMode) || 'root';

                    // Propagate mode into progression builder (used when generating chords for degrees)
                    if (this.progressionBuilder && this.progressionBuilder.state) {
                        this.progressionBuilder.state.harmonizationMode = m;
                    }

                    // Ensure progression builder has current numbers (it normally listens to numbersChanged).
                    // If the user has manually-entered display tokens (roman numerals/chord labels),
                    // prefer preserving those tokens and DO NOT regenerate the progression because
                    // generation can overwrite the user's explicit choices.
                    const hasManualDisplay = this.numberGenerator && this.numberGenerator.state && Array.isArray(this.numberGenerator.state.displayTokens) && this.numberGenerator.state.displayTokens.length > 0;
                    if (hasManualDisplay) {
                        try {
                            if (!window.__interactionLog) window.__interactionLog = [];
                            window.__interactionLog.push({ type: 'harmonizeSkippedRegenerate', details: { reason: 'manualDisplayTokensPresent', mode: m }, timestamp: new Date().toISOString() });
                        } catch (_) {}
                        // Inform the sheet of the harmonization mode and re-emit the display tokens so
                        // the existing display -> sheet mapping runs under the new mode (no regeneration).
                        if (this.sheetMusicGenerator && typeof this.sheetMusicGenerator.setHarmonizationMode === 'function') {
                            this.sheetMusicGenerator.setHarmonizationMode(m);
                        }
                        try {
                            const disp = this.numberGenerator && this.numberGenerator.state && Array.isArray(this.numberGenerator.state.displayTokens)
                                ? this.numberGenerator.state.displayTokens.slice()
                                : null;
                            const raw = this.numberGenerator && this.numberGenerator.state && Array.isArray(this.numberGenerator.state.displayRawTokens)
                                ? this.numberGenerator.state.displayRawTokens.slice()
                                : null;
                            if (disp && disp.length) {
                                this.numberGenerator.emit('displayTokensChanged', { tokens: disp, rawTokens: raw || disp });
                            }
                        } catch (_) { /* non-fatal */ }
                        return;
                    }

                    const currentNumbers = (this.numberGenerator && typeof this.numberGenerator.getCurrentNumbers === 'function')
                        ? this.numberGenerator.getCurrentNumbers()
                        : [];
                    if (this.progressionBuilder && Array.isArray(currentNumbers)) {
                        this.progressionBuilder.state.inputNumbers = currentNumbers.slice();
                        if (typeof this.progressionBuilder.generateProgression === 'function') {
                            this.progressionBuilder.generateProgression();
                        }
                    }

                    // Also inform the sheet music generator of the requested harmonization mode
                    if (this.sheetMusicGenerator && typeof this.sheetMusicGenerator.setHarmonizationMode === 'function') {
                        this.sheetMusicGenerator.setHarmonizationMode(m);
                    }

                    // If the user has manual display tokens present, re-emit the displayTokensChanged
                    // event so the existing handler maps tokens into the sheet with the new mode.
                    try {
                        const disp = this.numberGenerator && this.numberGenerator.state && Array.isArray(this.numberGenerator.state.displayTokens)
                            ? this.numberGenerator.state.displayTokens.slice()
                            : null;
                        const raw = this.numberGenerator && this.numberGenerator.state && Array.isArray(this.numberGenerator.state.displayRawTokens)
                            ? this.numberGenerator.state.displayRawTokens.slice()
                            : null;
                        if (disp && disp.length) {
                            this.numberGenerator.emit('displayTokensChanged', { tokens: disp, rawTokens: raw || disp });
                        }
                    } catch (_) { /* non-fatal */ }

                } catch (e) {
                    console.error('harmonizeCurrentSequence failed', e);
                }
            }

            setupEventHandlers() {
                // Sync fretboard to ScaleLibrary changes
                if (this.scaleLibrary && this.scaleLibrary.on) {
                    this.scaleLibrary.on('scaleChanged', ({ key, scale, notes }) => {
                        if (this.guitarFretboard && this.guitarFretboard.renderScale) {
                            this.guitarFretboard.renderScale({ key, scale, notes });
                        }
                    });
                    this.scaleLibrary.on('degreeHighlighted', ({ note }) => {
                        if (this.guitarFretboard && this.guitarFretboard.highlightNote) {
                            this.guitarFretboard.highlightNote(note);
                        }
                    });
                    this.scaleLibrary.on('highlightingCleared', () => {
                        if (this.guitarFretboard && this.guitarFretboard.renderScale) {
                            const key = this.scaleLibrary.getCurrentKey();
                            const scale = this.scaleLibrary.getCurrentScale();
                            const notes = this.scaleLibrary.getCurrentScaleNotes();
                            this.guitarFretboard.renderScale({ key, scale, notes });
                        }
                    });
                }
                // Audio Engine Listeners + propagate to guitar
                if (this.pianoVisualizer && this.pianoVisualizer.on) {
                    this.pianoVisualizer.on('noteClicked', (data) => {
                        if (this.audioEngine) {
                            this.audioEngine.playNote(data.midi);
                        }
                        if (this.guitarFretboard && this.guitarFretboard.highlightMidi) {
                            this.guitarFretboard.highlightMidi(data.midi);
                        }
                    });
                }

                if (this.chordExplorer && this.chordExplorer.on) {
                    this.chordExplorer.on('radialMenuOpened', (data) => {
                        if (this.audioEngine && data.chord && data.chord.chordNotes) {
                            this.audioEngine.playChord(data.chord.chordNotes);
                        }
                    });
                }
                    
                    // Mount number generator
                    if (this.numberGenerator && this.numberGenerator.mount) {
                        this.numberGenerator.mount('#number-generator-container');
                    }
                    // Mount scale library
                    if (this.scaleLibrary && this.scaleLibrary.mount) {
                        this.scaleLibrary.mount('#scale-library-container');
                        // debugLog('ScaleLibrary mounted');
                    } else {
                        // debugLog('ERROR: ScaleLibrary missing or invalid');
                    }
                    // Mount main piano visualizer
                    if (this.pianoVisualizer && this.pianoVisualizer.mount) {
                        this.pianoVisualizer.mount('#piano-container');
                    }
                    // Mount guitar fretboard visualizer
                    if (this.guitarFretboard && this.guitarFretboard.mount) {
                        this.guitarFretboard.mount('#guitar-fretboard-container');
                        try {
                            const key = this.scaleLibrary.getCurrentKey();
                            const scale = this.scaleLibrary.getCurrentScale();
                            const notes = this.scaleLibrary.getCurrentScaleNotes();
                            this.guitarFretboard.renderScale({ key, scale, notes });
                        } catch(_) {}
                    }
                    // Mount container chord tool
                    if (this.containerChordTool && this.containerChordTool.mount) {
                        this.containerChordTool.mount('#container-chord-container');
                        // debugLog('ContainerChordTool mounted');
                    } else {
                        // debugLog('ERROR: ContainerChordTool missing or invalid');
                    }
                    // Mount scale relationship explorer
                    if (this.scaleRelationshipExplorer && this.scaleRelationshipExplorer.mount) {
                        this.scaleRelationshipExplorer.mount('#scale-relationship-container');
                    }
                    // Mount progression builder
                    if (this.progressionBuilder && this.progressionBuilder.mount) {
                        this.progressionBuilder.mount('#progression-builder-container');
                        // debugLog('ProgressionBuilder mounted');
                    } else {
                        // debugLog('ERROR: ProgressionBuilder missing or invalid');
                    }
                    // Mount scale circle explorer
                    if (this.scaleCircleExplorer && this.scaleCircleExplorer.mount) {
                        this.scaleCircleExplorer.mount('#scale-circle-container');
                        // debugLog('ScaleCircleExplorer mounted');
                    } else {
                        // debugLog('ERROR: ScaleCircleExplorer missing or invalid');
                    }
                    // Mount chord explorer
                    if (this.chordExplorer && this.chordExplorer.mount) {
                        this.chordExplorer.mount('#chord-explorer-container');
                    }
                    // Mount sheet music generator under chord explorer
                    if (this.sheetMusicGenerator && this.sheetMusicGenerator.mount) {
                        this.sheetMusicGenerator.mount('#sheet-music-container');
                    }
                    // Mount solar system visualizer (docked by default)
                    if (this.solarSystem && this.solarSystem.mount) {
                        const mountTarget = '#solar-dock-viewport';
                        this.solarSystem.mount(mountTarget);
                    }
                    // (condensed sidebar solar removed)
                    // Mobile autodetect: add class and slightly reduce solar size scale
                    const applyMobileClass = () => {
                        const isMobile = window.matchMedia('(max-width: 768px)').matches || /Mobi|Android/i.test(navigator.userAgent);
                        document.body.classList.toggle('is-mobile', !!isMobile);
                        if (this.solarSystem && typeof this.solarSystem.setSizeScale === 'function') {
                            this.solarSystem.setSizeScale(isMobile ? 0.9 : 1.0);
                        }
                    };
                    applyMobileClass();
                    window.addEventListener('resize', () => {
                        applyMobileClass();
                        if (this.solarSystem && typeof this.solarSystem.handleResize === 'function') {
                            this.solarSystem.handleResize();
                        }
                    });
                    const avBtn = document.getElementById('open-audio-visualizer');
                    if (avBtn && this.audioVisualizer) {
                        avBtn.addEventListener('click', () => this.audioVisualizer.open());
                    }
                    // Auto-play solar system if possible
                    if (this.solarSystem && typeof this.solarSystem.start === 'function') {
                        try { this.solarSystem.start(); } catch(e) { /* ignore */ }
                    }
                    // Dock/Undock control
                    const dockBtn = document.getElementById('dock-solar');
                    if (dockBtn) {
                        // Initially docked
                        dockBtn.setAttribute('data-docked', 'true');
                        dockBtn.textContent = '[UNDOCK]';

                        dockBtn.addEventListener('click', () => {
                            const dockModule = document.getElementById('solar-docked-module');
                            const dockViewport = document.getElementById('solar-dock-viewport');
                            const sunViewport = document.getElementById('sun-viewport');
                            const isDocked = !dockModule.classList.contains('hidden');
                            try {
                                this.solarSystem.unmount();
                                if (!isDocked) {
                                    // Dock into grid
                                    dockModule.classList.remove('hidden');
                                    const sunEl = document.querySelector('.sun');
                                    if (sunEl) sunEl.style.display = 'none';
                                    this.solarSystem.mount('#solar-dock-viewport');
                                    dockBtn.textContent = '[UNDOCK]';
                                    // keep alternate dock button in sync
                                    const dockAlt = document.getElementById('dock-solar-alt');
                                    if (dockAlt) dockAlt.setAttribute('data-docked', 'true');
                                    dockBtn.setAttribute('data-docked', 'true');
                                } else {
                                    // Undock back to sun
                                    dockModule.classList.add('hidden');
                                    const sunEl = document.querySelector('.sun');
                                    if (sunEl) sunEl.style.display = 'flex';
                                    this.solarSystem.mount('#sun-viewport');
                                    dockBtn.textContent = '[DOCK]';
                                    const dockAlt = document.getElementById('dock-solar-alt');
                                    if (dockAlt) dockAlt.setAttribute('data-docked', 'false');
                                    dockBtn.setAttribute('data-docked', 'false');
                                }
                            } catch (e) { console.error(e); }
                        });
                        // Also add alternate dock/undock listener if present in controls
                        const dockAlt = document.getElementById('dock-solar-alt');
                        if (dockAlt) {
                            dockAlt.addEventListener('click', () => dockBtn.click());
                            // Initially docked
                            dockAlt.setAttribute('data-docked', 'true');
                        }
                    }
                } catch (error) {
                    // debugLog(`FATAL ERROR: ${error.message}`);
                    console.error(error);
                }
            renderInitialState() {
                // Set initial scale
                this.scaleLibrary.setKeyAndScale('C', 'major');

                // Immediately render the main piano with current scale on first load
                if (this.pianoVisualizer && this.pianoVisualizer.renderScale) {
                    const currentKey = this.scaleLibrary.getCurrentKey();
                    const currentScale = this.scaleLibrary.getCurrentScale();
                    const currentNotes = this.scaleLibrary.getCurrentScaleNotes();
                    
                    // First adjust the piano range to start from the selected key
                    if (this.pianoVisualizer.adjustPianoRange) {
                        this.pianoVisualizer.adjustPianoRange(currentKey);
                    }
                    
                    // Then render the scale
                    this.pianoVisualizer.renderScale({
                        key: currentKey,
                        scale: currentScale,
                        notes: currentNotes
                    });
                }

                // Set initial scale info for number generator
                this.numberGenerator.setScaleInfo('C', 'major');

                // Initialize container chord tool with key/scale context BEFORE generating numbers
                // so it's ready when bubbles are clicked
                this.containerChordTool.setKeyAndScale('C', 'major');

                // Set initial numbers to a simple diatonic run [1,2,3,4,5,6,7]
                // so all modules (Progression Builder, Sheet Music, Explorer)
                // start from the full scale by default.
                this.numberGenerator.setNumbers([1,2,3,4,5,6,7], this.numberGenerator.getNumberType());
                // Re-render the number generator UI to reflect the explicit numbers
                if (typeof this.numberGenerator.render === 'function') this.numberGenerator.render();
                // Initialize solar system with current key/scale
                if (this.solarSystem) {
                    this.solarSystem.updateSystem({
                        key: this.scaleLibrary.getCurrentKey(),
                        scale: this.scaleLibrary.getCurrentScale(),
                        notes: this.scaleLibrary.getCurrentScaleNotes()
                    });
                }
                
                // Initialize circle explorer
                this.scaleCircleExplorer.setKey('C');
                const miniPianoContainer = document.getElementById('mini-piano-visualize-container');
                if (miniPianoContainer) {
                    miniPianoContainer.innerHTML = this.numberGenerator.renderMiniPiano();
                }
                // Update citation display
                const compactInfoContainer = document.getElementById('piano-scale-info-compact');
                const expandedInfoContainer = document.getElementById('piano-scale-info');
                
                if (compactInfoContainer && expandedInfoContainer) {
                    const currentScale = this.scaleLibrary.getCurrentScale();
                    renderScaleCitation(currentScale, compactInfoContainer, expandedInfoContainer);
                }
            }
        }

        // Debug logging
        function debugLog(message) {
            // const console = document.getElementById('debug-console');
            // console.innerHTML += `<div>${new Date().toLocaleTimeString()}: ${message}</div>`;
            // console.scrollTop = console.scrollHeight;
        }

        // Citation display functions
        function getConfidenceIndicator(status) {
            switch(status) {
                case 'verified': return '<span class="confidence-verified">‚úÖ Well-documented</span>';
                case 'needs-review': return '<span class="confidence-review">‚ö†Ô∏è Limited documentation</span>';
                case 'limited-documentation': return '<span class="confidence-limited">‚ùì Needs review</span>';
                default: return '';
            }
        }

        function renderScaleCitation(scaleType, compactContainer, expandedContainer) {
            if (!window.modularApp || !window.modularApp.musicTheory) {
                return;
            }
            
            const musicTheory = window.modularApp.musicTheory;
            const citation = musicTheory.getScaleCitation(scaleType, 'html');
            const status = musicTheory.scaleCitations[scaleType]?.validationStatus;
            
            // Update compact display with confidence indicator
            const indicator = getConfidenceIndicator(status);
            if (compactContainer) {
                compactContainer.innerHTML = indicator ? indicator.replace(/<[^>]*>/g, '').substring(0, 10) : 'Info';
            }
            
            // Update expanded display with full citation and confidence indicator
            if (expandedContainer) {
                if (!citation || citation.includes('Scale derivation not documented')) {
                    expandedContainer.innerHTML = '<div class="no-sources">No academic sources found</div>';
                } else {
                    expandedContainer.innerHTML = indicator + '<br>' + citation;
                }
            }
        }

        // Initialize the modular app when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            window.modularApp = new ModularMusicTheoryApp();
            // Expose key components globally for lexical integration
            window.numberGenerator = window.modularApp.numberGenerator;
            window.scaleLibrary = window.modularApp.scaleLibrary;
            window.containerChordTool = window.modularApp.containerChordTool;
            window.progressionBuilder = window.modularApp.progressionBuilder;
            console.log('[App] Global references exposed:', {
                numberGenerator: !!window.numberGenerator,
                scaleLibrary: !!window.scaleLibrary
            });
            // Expose key components globally for lexical integration
            window.numberGenerator = window.modularApp.numberGenerator;
            window.scaleLibrary = window.modularApp.scaleLibrary;
            window.containerChordTool = window.modularApp.containerChordTool;
            window.progressionBuilder = window.modularApp.progressionBuilder;
            console.log('[App] Global references exposed:', {
                numberGenerator: !!window.numberGenerator,
                scaleLibrary: !!window.scaleLibrary
            });
            // debugLog('Application started');
            
            // Setup control deck elements
            setupControlDeck();
            
            // Setup module toggle functionality
            setupModuleControls();
        });
        
        // Setup control deck global controls
        function setupControlDeck() {
            const app = window.modularApp;
            if (!app) return;
            
            // Enhanced Grading View Selector
            const gradingSelector = document.getElementById('global-grading-type');
            if (gradingSelector && app.musicTheory) {
                // Set initial value from music theory engine
                gradingSelector.value = app.musicTheory.gradingMode || 'functional';
                
                gradingSelector.addEventListener('change', (e) => {
                    app.musicTheory.setGradingMode(e.target.value);
                    updateGradingDescription(e.target.value);
                });
                
                // Update grading key legend when grading mode changes
                app.musicTheory.subscribe((event, data) => {
                    if (event === 'gradingModeChanged') {
                        updateGradingKeyLegend();
                        updateGradingDescription(data.mode);
                    }
                });
                
                // Initial render of grading key and description
                updateGradingKeyLegend();
                updateGradingDescription(gradingSelector.value);
            }
            
            // Grading Influence Controls
            setupGradingInfluenceControls(app);
            
            // Grading Preview and Tutorial
            setupGradingPreviewAndTutorial(app);
            
            // Global Manual Input
            const globalInput = document.getElementById('global-manual-numbers');
            if (globalInput && app.numberGenerator) {
                // Mirror local manual-numbers input behavior
                globalInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        const value = e.target.value.trim();
                        if (!value) return;
                        
                        const tokens = value.split(/[\s,]+/).filter(t => t.length > 0);
                        
                        // Preview first
                        try { 
                            app.numberGenerator.setDisplayTokens(tokens, { rawTokens: tokens.slice(), emit: true }); 
                        } catch(_) {}
                        
                        // Commit via local input if present, or emit directly
                        const localInput = document.querySelector('#manual-numbers');
                        if (localInput) {
                            localInput.value = value;
                            try { 
                                app.numberGenerator.commitManualNumbers(localInput, { force: true }); 
                            } catch(e) { 
                                console.warn(e); 
                            }
                        } else {
                            try { 
                                app.numberGenerator.emit('displayTokensCommitted', { tokens, rawTokens: tokens }); 
                            } catch(_) {}
                        }
                        
                        // Clear global input
                        globalInput.value = '';
                    }
                });
            }
            
            function updateGradingKeyLegend() {
                const legend = document.getElementById('grading-key-legend');
                if (legend && app.musicTheory) {
                    const tiers = [4, 3, 2, 1, 0];
                    const items = tiers.map(t => {
                        const info = app.musicTheory.getGradingTierInfo(t);
                        return `<div style="display:flex; flex-direction:column; align-items:center; gap:2px;">
                            <div style="display:flex; align-items:center; gap:4px;">
                                <div style="width:12px; height:12px; background:${info.color}; border-radius:2px;"></div>
                                <span style="color:${info.color}; font-weight:600;">${info.short}</span>
                            </div>
                            <span style="font-size:0.65rem; color:${info.color}; opacity:0.8; white-space:nowrap;">${info.name}</span>
                        </div>`;
                    });
                    legend.innerHTML = items.join('');
                }
                
                // Also update sidebar grading key
                const sidebar = document.getElementById('grading-key-sidebar');
                if (sidebar && app.musicTheory) {
                    const mode = app.musicTheory.gradingMode || 'functional';
                    const tiers = [4, 3, 2, 1, 0];
                    const items = tiers.map(t => {
                        const info = app.musicTheory.getGradingTierInfo(t);
                        return `<div style="margin-bottom:12px;">
                            <div style="display:flex; align-items:center; gap:6px; margin-bottom:4px;">
                                <div style="width:16px; height:16px; background:${info.color}; border-radius:3px; flex-shrink:0;"></div>
                                <span style="color:${info.color}; font-weight:bold; font-size:0.9rem;">${info.short} ${info.name}</span>
                            </div>
                            <div style="font-size:0.75rem; opacity:0.7; margin-left:22px;">${info.desc}</div>
                        </div>`;
                    });
                    sidebar.innerHTML = `
                        <div style="padding:10px;">
                            <div style="margin-bottom:10px; font-weight:600; text-transform:uppercase; letter-spacing:0.04em; font-size:0.68rem; color:var(--text-secondary);">
                                Chord Grading (${mode})
                            </div>
                            ${items.join('')}
                        </div>
                    `;
                }
            }
            
            function updateGradingDescription(mode) {
                // Update any grading description displays
                const descriptions = {
                    functional: 'Analyzes harmonic function and voice leading',
                    emotional: 'Evaluates emotional impact and mood',
                    color: 'Color-based visual organization'
                };
                
                // Update tooltip or description if elements exist
                const gradingSelector = document.getElementById('global-grading-type');
                if (gradingSelector) {
                    gradingSelector.title = descriptions[mode] || 'Grading analysis mode';
                }
                
                // Update any description display elements
                const descriptionElement = document.getElementById('grading-description');
                if (descriptionElement) {
                    descriptionElement.textContent = descriptions[mode] || '';
                }
            }
            
            function setupGradingInfluenceControls(app) {
                // Setup visual influence slider
                const visualSlider = document.getElementById('visual-influence');
                const visualValue = document.getElementById('visual-influence-value');
                
                if (visualSlider && visualValue) {
                    visualSlider.addEventListener('input', (e) => {
                        const value = e.target.value;
                        visualValue.textContent = value + '%';
                        // Update app grading influence if method exists
                        if (app.musicTheory && app.musicTheory.setVisualInfluence) {
                            app.musicTheory.setVisualInfluence(value / 100);
                        }
                    });
                }
                
                // Setup behavior influence slider
                const behaviorSlider = document.getElementById('behavior-influence');
                const behaviorValue = document.getElementById('behavior-influence-value');
                
                if (behaviorSlider && behaviorValue) {
                    behaviorSlider.addEventListener('input', (e) => {
                        const value = e.target.value;
                        behaviorValue.textContent = value + '%';
                        // Update app grading influence if method exists
                        if (app.musicTheory && app.musicTheory.setBehaviorInfluence) {
                            app.musicTheory.setBehaviorInfluence(value / 100);
                        }
                    });
                }
            }
            
            function setupGradingPreviewAndTutorial(app) {
                // Setup grading preview button
                const previewBtn = document.getElementById('grading-preview-btn');
                if (previewBtn) {
                    previewBtn.addEventListener('click', () => {
                        // Show grading preview if method exists
                        if (app.musicTheory && app.musicTheory.showGradingPreview) {
                            app.musicTheory.showGradingPreview();
                        } else {
                            console.log('Grading preview functionality not yet implemented');
                        }
                    });
                }
                
                // Setup grading tutorial button
                const tutorialBtn = document.getElementById('grading-tutorial-btn');
                if (tutorialBtn) {
                    tutorialBtn.addEventListener('click', () => {
                        // Show grading tutorial if method exists
                        if (app.tutorialSystem && app.tutorialSystem.startGradingTutorial) {
                            app.tutorialSystem.startGradingTutorial();
                        } else {
                            console.log('Grading tutorial functionality not yet implemented');
                        }
                    });
                }
            }
        }
        
        // Module toggle and dropdown controls
        function setupModuleControls() {
            // Setup Settings Dropdown
            const settingsBtn = document.getElementById('settings-dropdown-btn');
            const settingsPanel = document.getElementById('settings-dropdown-panel');
            
            if (settingsBtn && settingsPanel) {
                settingsBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // Close other dropdowns
                    document.getElementById('help-dropdown-panel')?.classList.remove('open');
                    // Toggle settings dropdown
                    settingsPanel.classList.toggle('open');
                });
            }
            
            // Setup Help Dropdown
            const helpBtn = document.getElementById('help-dropdown-btn');
            const helpPanel = document.getElementById('help-dropdown-panel');
            
            if (helpBtn && helpPanel) {
                helpBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // Close other dropdowns
                    document.getElementById('settings-dropdown-panel')?.classList.remove('open');
                    // Toggle help dropdown
                    helpPanel.classList.toggle('open');
                });
            }
            
            // Close dropdowns when clicking outside
            document.addEventListener('click', (e) => {
                const dropdowns = [settingsPanel, helpPanel];
                dropdowns.forEach(dropdown => {
                    if (dropdown && !dropdown.contains(e.target) && 
                        !e.target.closest('#settings-dropdown-btn') && 
                        !e.target.closest('#help-dropdown-btn')) {
                        dropdown.classList.remove('open');
                    }
                });
            });
            
            // Handle checkbox toggles for module visibility
            const toggleCheckboxes = document.querySelectorAll('.module-toggle-item input[type="checkbox"]');
            toggleCheckboxes.forEach(checkbox => {
                checkbox.addEventListener('change', () => {
                    const moduleName = checkbox.getAttribute('data-module');
                    const module = document.querySelector(`.planet-module[data-module="${moduleName}"]`);
                    const sunElement = document.querySelector('.sun');
                    
                    if (moduleName === 'solar' && sunElement) {
                        sunElement.style.display = checkbox.checked ? 'flex' : 'none';
                    } else if (module) {
                        module.classList.toggle('hidden', !checkbox.checked);
                    }
                });
            });
            
            // Handle collapse buttons within each module
            const collapseButtons = document.querySelectorAll('.module-collapse-btn');
            collapseButtons.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const module = btn.closest('.planet-module');
                    const isCollapsed = module.classList.contains('collapsed');
                    
                    module.classList.toggle('collapsed', !isCollapsed);
                    btn.textContent = isCollapsed ? '‚àí' : '+';
                });
            });
            
            // Sync initial checkbox state with module visibility
            toggleCheckboxes.forEach(checkbox => {
                const moduleName = checkbox.getAttribute('data-module');
                if (moduleName === 'solar') {
                    const sunElement = document.querySelector('.sun');
                    const visible = !sunElement || sunElement.style.display !== 'none';
                    checkbox.checked = visible;
                } else {
                    const module = document.querySelector(`.planet-module[data-module="${moduleName}"]`);
                    const visible = module ? !module.classList.contains('hidden') : true;
                    checkbox.checked = visible;
                }
            });
        }
        
        function setupModuleDrag() {
            const modules = document.querySelectorAll('.planet-module');
            const grid = document.querySelector('.modules-grid');
            
            modules.forEach(module => {
                const header = module.querySelector('.module-header');
                let isDragging = false;
                let startX, startY, startScrollLeft, startScrollTop;
                
                header.addEventListener('mousedown', (e) => {
                    // Only drag if not clicking on collapse button
                    if (e.target.classList.contains('module-collapse-btn')) return;
                    
                    isDragging = true;
                    startX = e.pageX;
                    startY = e.pageY;
                    module.style.opacity = '0.7';
                    module.style.cursor = 'grabbing';
                    header.style.cursor = 'grabbing';
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    e.preventDefault();
                    
                    const deltaX = e.pageX - startX;
                    const deltaY = e.pageY - startY;
                    
                    // Visual feedback during drag
                    module.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                });
                
                document.addEventListener('mouseup', (e) => {
                    if (!isDragging) return;
                    
                    isDragging = false;
                    module.style.opacity = '1';
                    module.style.cursor = 'default';
                    header.style.cursor = 'move';
                    
                    const deltaX = e.pageX - startX;
                    const deltaY = e.pageY - startY;
                    
                    // If dragged significantly, reorder in grid
                    if (Math.abs(deltaX) > 50 || Math.abs(deltaY) > 50) {
                        const allModules = Array.from(grid.querySelectorAll('.planet-module'));
                        const fromIndex = allModules.indexOf(module);
                        
                        // Find closest module to drop position
                        let closestModule = null;
                        let closestDistance = Infinity;
                        
                        allModules.forEach((otherModule, index) => {
                            if (otherModule === module) return;
                            
                            const rect = otherModule.getBoundingClientRect();
                            const centerX = rect.left + rect.width / 2;
                            const centerY = rect.top + rect.height / 2;
                            const distance = Math.sqrt(
                                Math.pow(e.pageX - centerX, 2) + 
                                Math.pow(e.pageY - centerY, 2)
                            );
                            
                            if (distance < closestDistance) {
                                closestDistance = distance;
                                closestModule = otherModule;
                            }
                        });
                        
                        // Reorder if we found a close module
                        if (closestModule && closestDistance < 200) {
                            const toIndex = allModules.indexOf(closestModule);
                            if (toIndex < fromIndex) {
                                grid.insertBefore(module, closestModule);
                            } else {
                                grid.insertBefore(module, closestModule.nextSibling);
                            }
                        }
                    }
                    
                    // Reset transform
                    module.style.transform = '';
                });
            });
        }
    </script>
    <script>
(function() {
    // Interaction log buffer
    window.__interactionLog = window.__interactionLog || [];
    function logInteraction(type, details) {
        const entry = {
            type,
            details,
            timestamp: new Date().toISOString()
        };
        window.__interactionLog.push(entry);
        console.log('[InteractionLog]', entry);
    }
    // Handle clicks outside word input to dismiss panel
    document.addEventListener('click', function(e) {
        const wordInput = document.getElementById('global-word-input');
        const analysisPanel = document.getElementById('word-analysis-panel');
        
        // If clicking outside word input and analysis panel, mark as dismissing
        if (wordInput && analysisPanel && 
            !wordInput.contains(e.target) && 
            !analysisPanel.contains(e.target) &&
            analysisPanel.classList.contains('active')) {
            isUserDismissingPanel = true;
        }
    });
    
    // Click logger
    document.addEventListener('click', function(e) {
        let target = e.target;
        let info = {
            tag: target.tagName,
            id: target.id,
            class: target.className,
            text: target.innerText,
            value: target.value || null
        };
        logInteraction('click', info);
    }, true);
    // Key logger (skip manual input which has its own richer logger)
    document.addEventListener('keydown', function(e) {
        try {
            if (e.target && e.target.id === 'manual-numbers') return; // manual input logged separately
            logInteraction('keydown', {
                key: e.key,
                code: e.code,
                target: e.target.tagName,
                id: e.target.id,
                value: e.target.value || null
            });
        } catch (err) { console.warn('key logger failed', err); }
    }, true);
    // Error logger
    window.addEventListener('error', function(e) {
        logInteraction('error', {
            message: e.message,
            filename: e.filename,
            lineno: e.lineno,
            colno: e.colno,
            error: e.error ? e.error.stack : null
        });
    });
    // Chord commit logger (for ModularMusicTheoryApp)
    window.addEventListener('chordCommitted', function(e) {
        // If a richer UI logger already recorded this commit, skip duplicate
        try {
            if (e.detail && e.detail._loggedByUI) return;
        } catch (_) {}
        logInteraction('chordCommitted', e.detail);
    });
    // Explorer action logger
    window.addEventListener('explorerAction', function(e) {
        logInteraction('explorerAction', e.detail);
    });
    // Sheet music state logger
    window.addEventListener('sheetMusicUpdated', function(e) {
        logInteraction('sheetMusicUpdated', e.detail);
    });
    // Save log to file (File System Access API or download)
    async function saveLogToFile() {
        const logStr = JSON.stringify(window.__interactionLog, null, 2);
        if (window.showSaveFilePicker) {
            try {
                const handle = await window.showSaveFilePicker({
                    suggestedName: 'interaction-log.json',
                    types: [{ description: 'JSON', accept: { 'application/json': ['.json'] } }]
                });
                const writable = await handle.createWritable();
                await writable.write(logStr);
                await writable.close();
                logInteraction('save', { method: 'FileSystemAccessAPI', success: true });
            } catch (err) {
                logInteraction('save', { method: 'FileSystemAccessAPI', success: false, error: err });
            }
        } else {
            const blob = new Blob([logStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'interaction-log.json';
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 1000);
            logInteraction('save', { method: 'download', success: true });
        }
    }
    window.addEventListener('DOMContentLoaded', function() {
        const btn = document.createElement('button');
        btn.innerText = 'üíæ';
        btn.title = 'Save Interaction Log';
        btn.style.position = 'fixed';
        btn.style.top = '8px';
        btn.style.right = '12px';
        btn.style.zIndex = 9999;
        btn.style.background = 'rgba(0, 0, 0, 0.6)';
        btn.style.color = 'var(--accent-primary)';
        btn.style.border = '1px solid var(--border-light)';
        btn.style.borderRadius = '0';
        btn.style.padding = '4px 8px';
        btn.style.fontSize = '14px';
        btn.style.cursor = 'pointer';
        btn.style.opacity = '0.5';
        btn.style.transition = 'opacity 0.2s ease';
        btn.onmouseenter = () => btn.style.opacity = '1';
        btn.onmouseleave = () => btn.style.opacity = '0.5';
        btn.onclick = saveLogToFile;
        document.body.appendChild(btn);
    });
    // Utility: fire custom events from app code
    window.logChordCommit = function(detail) {
        // Log UI state at chord commit
        const chordNames = Array.from(document.querySelectorAll('div.chord-name')).map(e => e.textContent);
        const chordCards = Array.from(document.querySelectorAll('div.chord-card')).map(e => e.textContent);
        const sheetMusicSVG = Array.from(document.querySelectorAll('div.sheet-music-svg-host')).map(e => e.innerHTML);
        if (!window.__interactionLog) window.__interactionLog = [];
        try { detail = Object.assign({}, detail, { _loggedByUI: true }); } catch(_) {}
        window.__interactionLog.push({
            type: 'chordCommitted',
            details: detail,
            uiState: {
                chordNames,
                chordCards,
                sheetMusicSVG
            },
            timestamp: new Date().toISOString()
        });
        console.debug('[InteractionLog][UI] chordCommitted logged with uiState', { chordNames, chordCards, sheetMusicSVG });
        window.dispatchEvent(new CustomEvent('chordCommitted', { detail }));
    };
    // Preview tokens logger (used during manual typing/preview)
    window.logPreviewTokens = function(detail) {
        // Capture UI state at preview time
        const chordNames = Array.from(document.querySelectorAll('div.chord-name')).map(e => e.textContent);
        const chordCards = Array.from(document.querySelectorAll('div.chord-card')).map(e => e.textContent);
        const sheetMusicSVG = Array.from(document.querySelectorAll('div.sheet-music-svg-host')).map(e => e.innerHTML);
        if (!window.__interactionLog) window.__interactionLog = [];
        window.__interactionLog.push({
            type: 'previewTokens',
            details: detail,
            uiState: {
                chordNames,
                chordCards,
                sheetMusicSVG
            },
            timestamp: new Date().toISOString()
        });
        console.debug('[InteractionLog][UI] previewTokens logged', { detail, chordNames, chordCards });
        try { window.dispatchEvent(new CustomEvent('previewTokens', { detail })); } catch(_) {}
    };
    window.logExplorerAction = function(detail) {
        window.dispatchEvent(new CustomEvent('explorerAction', { detail }));
    };
    window.logSheetMusicUpdate = function(detail) {
        window.dispatchEvent(new CustomEvent('sheetMusicUpdated', { detail }));
    };
    // Also log manual input changes (keydown) with UI state
    const manualInput = document.getElementById('manual-numbers');
    if (manualInput) {
        manualInput.addEventListener('keydown', function(e) {
            const chordNames = Array.from(document.querySelectorAll('div.chord-name')).map(el => el.textContent);
            const chordCards = Array.from(document.querySelectorAll('div.chord-card')).map(el => el.textContent);
            const sheetMusicSVG = Array.from(document.querySelectorAll('div.sheet-music-svg-host')).map(el => el.innerHTML);
            if (!window.__interactionLog) window.__interactionLog = [];
            const kdDetail = { key: e.key, code: e.code, target: e.target.tagName, id: e.target.id, value: e.target.value };
            try { kdDetail._loggedByUI = true; } catch(_) {}
            window.__interactionLog.push({
                type: 'keydown',
                details: kdDetail,
                uiState: {
                    chordNames,
                    chordCards,
                    sheetMusicSVG
                },
                timestamp: new Date().toISOString()
            });
            console.debug('[InteractionLog][UI] manual keydown logged', kdDetail, { chordNames, chordCards });
        });
    }

    // ==================== THEME SWITCHER ====================
    const themeSwitcher = document.getElementById('theme-switcher');
    const themeNames = ['clean-daw', 'channel-strip', 'matrix-fx', 'steam-2000'];
    const themeLabels = {
        'clean-daw': 'Clean DAW',
        'channel-strip': 'Channel Strip',
        'matrix-fx': 'Matrix FX',
        'steam-2000': 'Steam 2000'
    };
    
    // Load saved theme or use default
    let currentThemeIndex = 0;
    const savedTheme = localStorage.getItem('music-theory-theme');
    if (savedTheme && themeNames.includes(savedTheme)) {
        currentThemeIndex = themeNames.indexOf(savedTheme);
        document.body.setAttribute('data-theme', savedTheme);
    }
    
    // Update button text to show current theme
    themeSwitcher.textContent = `[${themeLabels[themeNames[currentThemeIndex]]}]`;
    
    // Cycle through themes on click
    themeSwitcher.addEventListener('click', () => {
        currentThemeIndex = (currentThemeIndex + 1) % themeNames.length;
        const newTheme = themeNames[currentThemeIndex];
        document.body.setAttribute('data-theme', newTheme);
        localStorage.setItem('music-theory-theme', newTheme);
        themeSwitcher.textContent = `[${themeLabels[newTheme]}]`;
        console.log('Theme switched to:', newTheme);
    });
})();

// ==================== TUTORIAL SYSTEM ====================
(function() {
    'use strict';
    
    const tutorialSteps = [
        {
            title: 'Welcome to Music Theory Studio',
            content: 'This tool helps you learn music theory step by step. Let\'s start with the basics: scales are collections of notes that sound good together.',
            target: '#scale-library-container',
            action: null
        },
        {
            title: 'Step 1: Choose Your Scale',
            content: 'Start with C Major - the simplest scale with no sharps or flats. Click the dropdown and select "C Major" to begin.',
            target: '#scale-library-container',
            action: () => {
                // Highlight scale dropdown
            }
        },
        {
            title: 'Step 2: See the Notes',
            content: 'Look at the Circle of Fifths on the left. The highlighted notes show which notes are in your chosen scale. C Major has: C, D, E, F, G, A, B.',
            target: '#scale-circle-container',
            action: null
        },
        {
            title: 'Step 3: Generate Numbers',
            content: 'Music uses numbers (degrees) to represent scale positions. Try the Number Generator to create a simple melody pattern like "1-3-5-1".',
            target: '#number-generator-container',
            action: null
        },
        {
            title: 'Step 4: Build Chords',
            content: 'Chords are multiple notes played together. The Sheet Music area shows chords built from your scale. These are the building blocks of harmony.',
            target: '[data-module="score"]',
            action: null
        },
        {
            title: 'Step 5: Play It',
            content: 'Click on the piano keys below to hear your scale and chords. The highlighted keys show which notes belong to your current scale.',
            target: '#piano-container',
            action: null
        },
        {
            title: 'Step 6: Explore Progressions',
            content: 'Try the manual input box at the top. Type chord numbers like "1 4 5 1" to create a classic chord progression. Press Enter to hear it!',
            target: '#global-manual-numbers',
            action: null
        },
        {
            title: 'You\'re Ready!',
            content: 'Now you understand the basics! Enable Demo Mode (button at top) to see explanations when you hover over any tool. Happy composing!',
            target: '#demo-mode-btn',
            action: null
        }
    ];
    
    const demoTooltips = {
        '#scale-library-container': {
            title: 'Scale Selector',
            content: 'Choose from hundreds of scales across different musical traditions. Each scale has a unique character and emotional quality.'
        },
        '#scale-circle-container': {
            title: 'Circle of Fifths',
            content: 'Visual reference showing all 12 notes. Highlighted notes belong to your current scale. Adjacent scales are closely related.'
        },
        '#number-generator-container': {
            title: 'Number Generator',
            content: 'Create melodies and progressions using scale degrees. Use patterns, random generation, or manual input to explore musical ideas.'
        },
        '#container-chord-container': {
            title: 'Container Chord Tool',
            content: 'Find what scales contain specific chords. Great for understanding chord-scale relationships and harmonic possibilities.'
        },
        '[data-module="score"]': {
            title: 'Sheet Music Generator',
            content: 'Visual notation of your progression. Shows chord symbols, staff notation, and harmonic analysis. Export as MIDI for your DAW.'
        },
        '[data-module="chord"]': {
            title: 'Chord Explorer',
            content: 'Interactive map of all diatonic chords in your scale. Click to hear, see voice leadings, and understand functional harmony.'
        },
        '#piano-container': {
            title: 'Piano Visualizer',
            content: 'Click keys to play notes and chords. Highlighted keys show your current scale. Visual feedback helps connect theory to sound.'
        },
        '#global-manual-numbers': {
            title: 'Manual Chord Input',
            content: 'Type chord progressions directly: "1 4 5 1" or "Cmaj7 Fmaj7". Supports Roman numerals, numbers, and chord symbols.'
        },
        '#global-grading-type': {
            title: 'Grading View',
            content: 'Change how chords are colored: Functional (tonic/dominant), Emotional (happy/sad), or Color (synesthesia-inspired).'
        },
        '#theme-switcher': {
            title: 'Theme Switcher',
            content: 'Cycle through visual themes: Clean DAW, Channel Strip, Matrix FX, or Steam 2000. Find your preferred workspace aesthetic.'
        },
        '#toggle-layout': {
            title: 'Layout Toggle',
            content: 'Switch between column layout and grid layout. Grid mode lets you drag-and-drop modules to customize your workspace.'
        },
        '.module-toggle-item': {
            title: 'Module Visibility',
            content: 'Show or hide individual modules. Customize your workspace to focus on the tools you\'re currently using.'
        }
    };
    
    let currentStep = 0;
    let easyModeActive = false;
    let demoModeActive = false;
    
    const overlay = document.getElementById('tutorial-overlay');
    const highlight = document.getElementById('tutorial-highlight');
    const tooltip = document.getElementById('tutorial-tooltip');
    const tooltipTitle = document.getElementById('tutorial-title');
    const tooltipContent = document.getElementById('tutorial-content');
    const progress = document.getElementById('tutorial-progress');
    const nextBtn = document.getElementById('tutorial-next');
    const skipBtn = document.getElementById('tutorial-skip');
    const demoTooltip = document.getElementById('demo-tooltip');
    const demoTooltipTitle = document.getElementById('demo-tooltip-title');
    const demoTooltipContent = document.getElementById('demo-tooltip-content');
    
    const easyModeBtn = document.getElementById('easy-mode-btn');
    const demoModeBtn = document.getElementById('demo-mode-btn');
    
    // Easy Mode Button
    easyModeBtn.addEventListener('click', () => {
        easyModeActive = !easyModeActive;
        
        if (easyModeActive) {
            startTutorial();
            easyModeBtn.style.color = 'var(--accent-secondary)';
            easyModeBtn.style.borderColor = 'var(--accent-secondary)';
            
            // Add badge
            if (!document.querySelector('.easy-mode-badge')) {
                const badge = document.createElement('div');
                badge.className = 'easy-mode-badge';
                badge.textContent = 'Easy Mode Active';
                document.body.appendChild(badge);
            }
        } else {
            stopTutorial();
            easyModeBtn.style.color = '';
            easyModeBtn.style.borderColor = '';
            
            const badge = document.querySelector('.easy-mode-badge');
            if (badge) badge.remove();
        }
    });
    
    // Demo Mode Button
    demoModeBtn.addEventListener('click', () => {
        demoModeActive = !demoModeActive;
        
        if (demoModeActive) {
            enableDemoMode();
            demoModeBtn.style.color = 'var(--accent-primary)';
            demoModeBtn.style.borderColor = 'var(--accent-primary)';
            
            // Add badge
            if (!document.querySelector('.demo-mode-badge')) {
                const badge = document.createElement('div');
                badge.className = 'demo-mode-badge';
                badge.textContent = 'Demo Mode Active';
                document.body.appendChild(badge);
            }
        } else {
            disableDemoMode();
            demoModeBtn.style.color = '';
            demoModeBtn.style.borderColor = '';
            
            const badge = document.querySelector('.demo-mode-badge');
            if (badge) badge.remove();
        }
    });
    
    function startTutorial() {
        currentStep = 0;
        showTutorialStep();
    }
    
    function stopTutorial() {
        overlay.classList.remove('active');
        highlight.style.display = 'none';
        tooltip.classList.remove('active');
        progress.classList.remove('active');
        easyModeActive = false;
    }
    
    function showTutorialStep() {
        if (currentStep >= tutorialSteps.length) {
            stopTutorial();
            return;
        }
        
        const step = tutorialSteps[currentStep];
        
        // Update content
        tooltipTitle.textContent = step.title;
        tooltipContent.textContent = step.content;
        
        // Update progress
        progress.textContent = `Step ${currentStep + 1} of ${tutorialSteps.length}`;
        progress.classList.add('active');
        
        // Show overlay
        overlay.classList.add('active');
        tooltip.classList.add('active');
        
        // Highlight target element
        if (step.target) {
            const target = document.querySelector(step.target);
            if (target) {
                const rect = target.getBoundingClientRect();
                highlight.style.display = 'block';
                highlight.style.left = rect.left + 'px';
                highlight.style.top = rect.top + 'px';
                highlight.style.width = rect.width + 'px';
                highlight.style.height = rect.height + 'px';
                
                // Position tooltip near target
                positionTooltip(tooltip, rect);
                
                // Allow clicking through overlay on target
                target.style.position = 'relative';
                target.style.zIndex = '10000';
            }
        }
        
        // Execute action if any
        if (step.action) {
            step.action();
        }
        
        // Update button text
        if (currentStep === tutorialSteps.length - 1) {
            nextBtn.textContent = 'Finish';
        } else {
            nextBtn.textContent = 'Next';
        }
    }
    
    function positionTooltip(tooltip, targetRect) {
        const tooltipRect = tooltip.getBoundingClientRect();
        const padding = 20;
        
        // Try to position to the right
        let left = targetRect.right + padding;
        let top = targetRect.top;
        
        // If doesn't fit on right, try left
        if (left + tooltipRect.width > window.innerWidth) {
            left = targetRect.left - tooltipRect.width - padding;
        }
        
        // If doesn't fit on left either, position below
        if (left < 0) {
            left = targetRect.left;
            top = targetRect.bottom + padding;
        }
        
        // Keep within viewport
        left = Math.max(padding, Math.min(left, window.innerWidth - tooltipRect.width - padding));
        top = Math.max(padding, Math.min(top, window.innerHeight - tooltipRect.height - padding));
        
        tooltip.style.left = left + 'px';
        tooltip.style.top = top + 'px';
    }
    
    nextBtn.addEventListener('click', () => {
        // Reset previous target z-index
        const prevStep = tutorialSteps[currentStep];
        if (prevStep && prevStep.target) {
            const prevTarget = document.querySelector(prevStep.target);
            if (prevTarget) {
                prevTarget.style.zIndex = '';
            }
        }
        
        currentStep++;
        showTutorialStep();
    });
    
    skipBtn.addEventListener('click', () => {
        stopTutorial();
    });
    
    // Demo Mode: Hover tooltips
    function enableDemoMode() {
        Object.keys(demoTooltips).forEach(selector => {
            const elements = document.querySelectorAll(selector);
            elements.forEach(el => {
                el.addEventListener('mouseenter', handleDemoHover);
                el.addEventListener('mouseleave', handleDemoLeave);
            });
        });
    }
    
    function disableDemoMode() {
        Object.keys(demoTooltips).forEach(selector => {
            const elements = document.querySelectorAll(selector);
            elements.forEach(el => {
                el.removeEventListener('mouseenter', handleDemoHover);
                el.removeEventListener('mouseleave', handleDemoLeave);
            });
        });
        demoTooltip.classList.remove('show');
    }
    
    function handleDemoHover(e) {
        const el = e.currentTarget;
        
        // Find matching tooltip data
        let tooltipData = null;
        for (const selector in demoTooltips) {
            if (el.matches(selector)) {
                tooltipData = demoTooltips[selector];
                break;
            }
        }
        
        if (!tooltipData) return;
        
        demoTooltipTitle.textContent = tooltipData.title;
        demoTooltipContent.textContent = tooltipData.content;
        
        // Position tooltip
        const rect = el.getBoundingClientRect();
        let left = rect.right + 10;
        let top = rect.top;
        
        // Keep within viewport
        if (left + 300 > window.innerWidth) {
            left = rect.left - 310;
        }
        if (left < 10) {
            left = rect.left;
            top = rect.bottom + 10;
        }
        
        demoTooltip.style.left = left + 'px';
        demoTooltip.style.top = top + 'px';
        demoTooltip.classList.add('show');
    }
    
    function handleDemoLeave() {
        demoTooltip.classList.remove('show');
    }
    
    // Check if user is first-time visitor
    const hasVisited = localStorage.getItem('music-theory-visited');
    if (!hasVisited) {
        setTimeout(() => {
            if (confirm('Welcome! Would you like a guided tour to learn the basics?')) {
                easyModeActive = true;
                startTutorial();
                easyModeBtn.style.color = 'var(--accent-secondary)';
                easyModeBtn.style.borderColor = 'var(--accent-secondary)';
                
                const badge = document.createElement('div');
                badge.className = 'easy-mode-badge';
                badge.textContent = 'Easy Mode Active';
                document.body.appendChild(badge);
            }
            localStorage.setItem('music-theory-visited', 'true');
        }, 1000);
    }

    // ========================================
    // LEXICAL MUSIC ENGINE INTEGRATION
    // ========================================
    
    // Initialize simple word engine
    let lexicalEngine = null;
    let lexicalWeights = {
        emotional: 0.30,
        syllabic: 0.20,
        phonetic: 0.15,
        semantic: 0.25,
        archetype: 0.10
    };
    let lexicalSettings = {
        aggressiveMapping: false,
        keyVariety: true,  // Enable dynamic key selection by default
        autoSend: true     // Auto-send to sheet music by default
    };
    
    // Global undo/redo history
    let globalHistory = [];
    let globalHistoryIndex = -1;
    const MAX_HISTORY = 50;

    // Wait for MusicTheoryEngine to be ready
    function initLexicalSystem() {
        if (typeof MusicTheoryEngine === 'undefined' || typeof SimpleWordEngine === 'undefined') {
            console.warn('[LexicalIntegration] Waiting for engine classes...');
            setTimeout(initLexicalSystem, 100);
            return;
        }
        
        try {
            const musicTheory = new MusicTheoryEngine();
            lexicalEngine = new SimpleWordEngine(musicTheory);
            lexicalEngine.debug = true; // Enable debug logging
            
            console.log('[LexicalIntegration] ‚úÖ SIMPLE WORD ENGINE INITIALIZED - direct word-to-music mapping');
            console.log('[LexicalIntegration] Engine type:', typeof lexicalEngine);
            console.log('[LexicalIntegration] Engine constructor:', lexicalEngine.constructor.name);
        } catch (err) {
            console.error('[LexicalIntegration] Initialization failed:', err);
        }
    }
    
    // Start initialization
    setTimeout(initLexicalSystem, 500);

    // Input mode toggle
    const inputModeWords = document.getElementById('input-mode-words');
    const inputModeNumbers = document.getElementById('input-mode-numbers');
    const globalWordInput = document.getElementById('global-word-input');
    const globalManualNumbers = document.getElementById('global-manual-numbers');

    if (inputModeWords && inputModeNumbers && globalWordInput && globalManualNumbers) {
        inputModeWords.addEventListener('click', () => {
            inputModeWords.classList.add('active');
            inputModeNumbers.classList.remove('active');
            globalWordInput.style.display = '';
            globalManualNumbers.style.display = 'none';
        });

        inputModeNumbers.addEventListener('click', () => {
            inputModeNumbers.classList.add('active');
            inputModeWords.classList.remove('active');
            globalManualNumbers.style.display = '';
            globalWordInput.style.display = 'none';
        });
    }

    // Word settings panel toggle
    const wordSettingsBtn = document.getElementById('word-settings-btn');
    const wordSettingsPanel = document.getElementById('word-settings-panel');
    
    if (wordSettingsBtn && wordSettingsPanel) {
        wordSettingsBtn.addEventListener('click', () => {
            wordSettingsPanel.classList.toggle('active');
            // Close analysis panel if open
            const analysisPanel = document.getElementById('word-analysis-panel');
            if (analysisPanel) analysisPanel.classList.remove('active');
        });
    }

    // Weight sliders
    const weightSliders = {
        emotional: document.getElementById('weight-emotional'),
        syllabic: document.getElementById('weight-syllabic'),
        phonetic: document.getElementById('weight-phonetic'),
        semantic: document.getElementById('weight-semantic'),
        archetype: document.getElementById('weight-archetype')
    };

    // Initialize sliders with current lexicalWeights values and add event listeners
    Object.keys(weightSliders).forEach(key => {
        const slider = weightSliders[key];
        if (slider) {
            // Sync slider with current lexicalWeights value
            const currentWeight = lexicalWeights[key] || 0;
            const sliderValue = Math.round(currentWeight * 100);
            slider.value = sliderValue;
            
            const valueDisplay = slider.nextElementSibling;
            if (valueDisplay) valueDisplay.textContent = sliderValue + '%';
            
            // Add event listener for changes
            slider.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                if (valueDisplay) valueDisplay.textContent = value + '%';
                lexicalWeights[key] = value / 100;
            });
        }
    });

    // Reset weights button
    const resetWeightsBtn = document.getElementById('reset-weights-btn');
    if (resetWeightsBtn) {
        resetWeightsBtn.addEventListener('click', () => {
            const defaults = { emotional: 30, syllabic: 20, phonetic: 15, semantic: 25, archetype: 10 };
            Object.keys(defaults).forEach(key => {
                const slider = weightSliders[key];
                if (slider) {
                    slider.value = defaults[key];
                    const valueDisplay = slider.nextElementSibling;
                    if (valueDisplay) valueDisplay.textContent = defaults[key] + '%';
                    lexicalWeights[key] = defaults[key] / 100;
                }
            });
        });
    }
    
    // Copy Lexical Log button
    const copyLexicalLogBtn = document.getElementById('copy-lexical-log-btn');
    if (copyLexicalLogBtn) {
        copyLexicalLogBtn.addEventListener('click', () => {
            copyLexicalLogToClipboard();
        });
    }

    // Debug Log button
    const debugLogBtn = document.getElementById('debug-log-btn');
    if (debugLogBtn) {
        debugLogBtn.addEventListener('click', () => {
            showDebugLog();
        });
    }
    // Export / Clear session log buttons (session log UI)
    const exportLexicalLogBtn = document.getElementById('export-lexical-log-btn');
    if (exportLexicalLogBtn) {
        exportLexicalLogBtn.addEventListener('click', () => exportLexicalLog());
    }
    const clearLexicalLogBtn = document.getElementById('clear-lexical-log-btn');
    if (clearLexicalLogBtn) {
        clearLexicalLogBtn.addEventListener('click', () => {
            if (!confirm('Clear lexical session log?')) return;
            window.__lexicalLog = [];
            try { renderLexicalLog(); } catch(_) {}
        });
    }
    
    // Randomize button
    const randomizeBtn = document.getElementById('word-randomize-btn');
    if (randomizeBtn) {
        randomizeBtn.addEventListener('click', () => {
            console.log('[LexicalIntegration] Randomizing weights...');
            
            // Generate random weights that sum to 100
            let remaining = 100;
            const keys = Object.keys(lexicalWeights);
            const randomWeights = {};
            
            keys.forEach((key, idx) => {
                if (idx === keys.length - 1) {
                    // Last one gets the remainder
                    randomWeights[key] = remaining;
                } else {
                    // Random value between 5 and 40
                    const value = Math.floor(Math.random() * 36) + 5;
                    randomWeights[key] = Math.min(value, remaining - (keys.length - idx - 1) * 5);
                    remaining -= randomWeights[key];
                }
            });
            
            // Apply random weights to sliders
            Object.keys(randomWeights).forEach(key => {
                const slider = weightSliders[key];
                if (slider) {
                    slider.value = randomWeights[key];
                    const valueDisplay = slider.nextElementSibling;
                    if (valueDisplay) valueDisplay.textContent = randomWeights[key] + '%';
                    lexicalWeights[key] = randomWeights[key] / 100;
                }
            });
            
            // Reprocess current input with new weights
            if (globalWordInput && globalWordInput.value.trim()) {
                console.log('[LexicalIntegration] Reprocessing with new weights:', lexicalWeights);
                processWordsInput(globalWordInput.value.trim());
            }
        });
    }

    // Aggressive mapping checkbox handling
    const aggressiveCheckbox = document.getElementById('weight-aggressive');
    if (aggressiveCheckbox) {
        aggressiveCheckbox.addEventListener('change', (e) => {
            lexicalSettings.aggressiveMapping = !!e.target.checked;
            console.log('[LexicalIntegration] aggressiveMapping set to', lexicalSettings.aggressiveMapping);
        });
    }

    // Key variety checkbox handling
    const keyVarietyCheckbox = document.getElementById('weight-key-variety');
    if (keyVarietyCheckbox) {
        keyVarietyCheckbox.addEventListener('change', (e) => {
            const enabled = !!e.target.checked;
            console.log('[LexicalIntegration] Key variety set to', enabled);
            lexicalSettings.keyVariety = enabled;
        });
    }
    
    // Auto-send checkbox handling
    const autoSendCheckbox = document.getElementById('weight-auto-send');
    if (autoSendCheckbox) {
        autoSendCheckbox.addEventListener('change', (e) => {
            lexicalSettings.autoSend = !!e.target.checked;
            console.log('[LexicalIntegration] Auto-send set to', lexicalSettings.autoSend);
        });
    }

    // Regenerate button (re-run translate with current weights)
    const regenerateBtn = document.getElementById('word-regenerate-btn');
    if (regenerateBtn) {
        regenerateBtn.addEventListener('click', () => {
            if (!globalWordInput || !globalWordInput.value.trim()) return;
            console.log('[LexicalIntegration] Regenerate pressed - using weights:', lexicalWeights);
            processWordsInput(globalWordInput.value.trim());
        });
    }

    // Send to Sheet button - uses latest lexical result to update NumberGenerator / Sheet
    const sendSheetBtn = document.getElementById('word-send-sheet-btn');
    if (sendSheetBtn) {
        sendSheetBtn.addEventListener('click', () => {
            const last = window.__lastLexicalResult;
            if (!last) {
                alert('No translation result available to send. Please generate one first.');
                return;
            }
            try {
                console.log('[LexicalIntegration] Sending latest result to sheet music');
                updateNumberGenerator(last);
                // Optional visual feedback
                const toast = document.createElement('div');
                toast.textContent = 'Sent to Sheet Music';
                toast.style.cssText = 'position:fixed;bottom:20px;right:20px;background:#10b981;color:#fff;padding:8px 12px;border-radius:4px;font-size:13px;z-index:10000;';
                document.body.appendChild(toast);
                setTimeout(() => toast.remove(), 1500);
            } catch (e) {
                console.error('[LexicalIntegration] Send to sheet failed', e);
                alert('Failed to send to sheet. See console.');
            }
        });
    }

    // Word input processing with debouncing
    let wordInputTimeout = null;
    let isUserDismissingPanel = false;
    let lastEnterTime = 0;
    
    if (globalWordInput) {
        // Remove any existing listeners to prevent duplicates
        if (globalWordInput._inputHandler) {
            globalWordInput.removeEventListener('input', globalWordInput._inputHandler);
        }
        if (globalWordInput._keydownHandler) {
            globalWordInput.removeEventListener('keydown', globalWordInput._keydownHandler);
        }
        if (globalWordInput._blurHandler) {
            globalWordInput.removeEventListener('blur', globalWordInput._blurHandler);
        }
        
        // Input event - just clear empty state, don't process
        globalWordInput._inputHandler = (e) => {
            const words = e.target.value.trim();
            
            if (!words) {
                // Clear analysis panel
                const analysisContent = document.getElementById('word-analysis-content');
                if (analysisContent) {
                    analysisContent.innerHTML = '<div class="analysis-empty">Enter words above to see analysis...</div>';
                }
            }
        };
        globalWordInput.addEventListener('input', globalWordInput._inputHandler);
        
        // Enter key - process immediately
        globalWordInput._keydownHandler = (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                clearTimeout(wordInputTimeout);
                const words = e.target.value.trim();
                if (words) {
                    console.log('[LexicalIntegration] Enter key pressed, processing immediately');
                    lastEnterTime = Date.now(); // Track when Enter was pressed
                    isUserDismissingPanel = false; // Enter key should show panel
                    processWordsInput(words);
                }
            }
        };
        globalWordInput.addEventListener('keydown', globalWordInput._keydownHandler);
        
        // Blur event - DISABLED to prevent double processing
        // Only process on Enter key, not on blur
        globalWordInput._blurHandler = (e) => {
            console.log('[LexicalIntegration] Blur event fired but processing DISABLED to prevent double processing');
            // Just set the dismissing flag, don't process
            isUserDismissingPanel = true;
        };
        globalWordInput.addEventListener('blur', globalWordInput._blurHandler);
    }

    /**
     * Global Undo/Redo System
     */
    function captureGlobalState() {
        try {
            return {
                timestamp: Date.now(),
                lexicalResult: window.__lastLexicalResult ? JSON.parse(JSON.stringify(window.__lastLexicalResult)) : null,
                wordInput: globalWordInput ? globalWordInput.value : '',
                weights: { ...lexicalWeights },
                settings: { ...lexicalSettings }
            };
        } catch (e) {
            console.warn('[Undo/Redo] Failed to capture state:', e);
            return null;
        }
    }
    
    function saveToHistory() {
        const state = captureGlobalState();
        if (!state) return;
        
        // Remove any future history if we're not at the end
        if (globalHistoryIndex < globalHistory.length - 1) {
            globalHistory = globalHistory.slice(0, globalHistoryIndex + 1);
        }
        
        globalHistory.push(state);
        if (globalHistory.length > MAX_HISTORY) {
            globalHistory.shift();
        } else {
            globalHistoryIndex++;
        }
        
        updateUndoRedoButtons();
        console.log('[Undo/Redo] Saved state', globalHistoryIndex, '/', globalHistory.length);
    }
    
    function restoreState(state) {
        if (!state) return;
        
        try {
            // Restore word input
            if (globalWordInput && state.wordInput !== undefined) {
                globalWordInput.value = state.wordInput;
            }
            
            // Restore weights
            if (state.weights) {
                Object.assign(lexicalWeights, state.weights);
                Object.keys(weightSliders).forEach(key => {
                    const slider = weightSliders[key];
                    if (slider && state.weights[key] !== undefined) {
                        slider.value = Math.round(state.weights[key] * 100);
                        const valueDisplay = slider.nextElementSibling;
                        if (valueDisplay) valueDisplay.textContent = Math.round(state.weights[key] * 100) + '%';
                    }
                });
            }
            
            // Restore settings
            if (state.settings) {
                Object.assign(lexicalSettings, state.settings);
            }
            
            // Restore and display result
            if (state.lexicalResult) {
                window.__lastLexicalResult = state.lexicalResult;
                updateAnalysisPanel(state.lexicalResult);
                if (lexicalSettings.autoSend) {
                    updateNumberGenerator(state.lexicalResult);
                }
            }
            
            console.log('[Undo/Redo] Restored state');
        } catch (e) {
            console.error('[Undo/Redo] Failed to restore state:', e);
        }
    }
    
    function globalUndo() {
        if (globalHistoryIndex <= 0) {
            console.log('[Undo/Redo] No more undo history');
            return;
        }
        
        globalHistoryIndex--;
        const state = globalHistory[globalHistoryIndex];
        restoreState(state);
        updateUndoRedoButtons();
        
        // Visual feedback
        showToast('‚Ü∂ Undo', '#64C8FF');
    }
    
    function globalRedo() {
        if (globalHistoryIndex >= globalHistory.length - 1) {
            console.log('[Undo/Redo] No more redo history');
            return;
        }
        
        globalHistoryIndex++;
        const state = globalHistory[globalHistoryIndex];
        restoreState(state);
        updateUndoRedoButtons();
        
        // Visual feedback
        showToast('‚Ü∑ Redo', '#10b981');
    }
    
    function updateUndoRedoButtons() {
        const undoBtn = document.getElementById('global-undo-btn');
        const redoBtn = document.getElementById('global-redo-btn');
        
        if (undoBtn) {
            undoBtn.disabled = globalHistoryIndex <= 0;
            undoBtn.style.opacity = globalHistoryIndex <= 0 ? '0.3' : '1';
        }
        
        if (redoBtn) {
            redoBtn.disabled = globalHistoryIndex >= globalHistory.length - 1;
            redoBtn.style.opacity = globalHistoryIndex >= globalHistory.length - 1 ? '0.3' : '1';
        }
    }
    
    function showToast(message, color = '#64C8FF') {
        const toast = document.createElement('div');
        toast.textContent = message;
        toast.style.cssText = `position:fixed;bottom:20px;right:20px;background:${color};color:#fff;padding:12px 20px;border-radius:6px;font-size:14px;font-weight:700;z-index:10000;box-shadow:0 4px 16px rgba(0,0,0,0.4);`;
        document.body.appendChild(toast);
        setTimeout(() => toast.remove(), 1500);
    }
    
    // Wire up undo/redo buttons
    const undoBtn = document.getElementById('global-undo-btn');
    const redoBtn = document.getElementById('global-redo-btn');
    if (undoBtn) undoBtn.addEventListener('click', globalUndo);
    if (redoBtn) redoBtn.addEventListener('click', globalRedo);
    
    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
            e.preventDefault();
            globalUndo();
        } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
            e.preventDefault();
            globalRedo();
        }
    });

    function copyLexicalLogToClipboard() {
        try {
            const logText = buildCompactLexicalLog();
            navigator.clipboard.writeText(logText).then(() => {
                console.log('[Lexical] Log copied to clipboard:\n' + logText);
                // Toast notification if available
                try {
                    const toast = document.createElement('div');
                    toast.textContent = 'Lexical log copied';
                    toast.style.cssText = 'position:fixed;bottom:20px;right:20px;background:#64C8FF;color:#000;padding:12px 20px;border-radius:4px;font-size:14px;z-index:10000;animation:fadeInOut 2s;';
                    document.body.appendChild(toast);
                    setTimeout(() => toast.remove(), 2000);
                } catch(_) {}
            }).catch(err => {
                alert('Failed to copy log. See console.');
                console.warn('[Lexical] Copy failed', err);
            });
        } catch (e) {
            alert('Failed to build log. See console.');
            console.error('[Lexical] Build log error', e);
        }
    }
    
    function buildCompactLexicalLog() {
        if (!window.__lexicalLog || window.__lexicalLog.length === 0) {
            return '[Lexical] No translations logged yet.';
        }
        
        const lines = [];
        lines.push('[Lexical Analysis Log]');
        lines.push('='.repeat(60));
        lines.push('');
        
        window.__lexicalLog.forEach((entry, idx) => {
            const time = new Date(entry.timestamp).toLocaleTimeString();
            lines.push(`#${idx + 1} [${time}] "${entry.input}"`);
            
            if (entry.result.scale) {
                const scaleStr = typeof entry.result.scale === 'object' 
                    ? `${entry.result.scale.root || entry.result.scale.key} ${entry.result.scale.name || entry.result.scale.scale}`
                    : entry.result.scale;
                lines.push(`  Scale: ${scaleStr}`);
            }
            
            if (entry.result.progression && entry.result.progression.length > 0) {
                const progStr = entry.result.progression.map(c => {
                    const name = c.fullName || c;
                    const degree = c.degree ? ` (${c.degree})` : '';
                    const func = c.function ? ` [${c.function}]` : '';
                    const tier = c.tier ? ` T${c.tier}` : '';
                    return name + degree + func + tier;
                }).join(' ‚Üí ');
                lines.push(`  Progression: ${progStr}`);
            }
            
            if (entry.result.complexity) {
                const cplx = entry.result.complexity;
                if (typeof cplx === 'object') {
                    lines.push(`  Complexity: H=${Math.round(cplx.harmonic*100)}% R=${Math.round(cplx.rhythmic*100)}% E=${Math.round(cplx.emotional*100)}% (${cplx.overall})`);
                } else {
                    lines.push(`  Complexity: ${cplx}`);
                }
            }
            
            if (entry.result.reasoning) {
                lines.push(`  Reasoning: ${entry.result.reasoning}`);
            }
            
            if (entry.weights) {
                const w = entry.weights;
                lines.push(`  Weights: Emotional=${w.emotional}% Semantic=${w.semantic}% Phonetic=${w.phonetic}% Arch=${w.archetype}%`);
            }
            
            lines.push('');
        });
        
        lines.push('='.repeat(60));
        lines.push(`Total translations: ${window.__lexicalLog.length}`);
        
        return lines.join('\n');
    }

    // Render in-page lexical session log with per-entry actions
    function renderLexicalLog() {
        const list = document.getElementById('lexical-log-list');
        if (!list) return;
        list.innerHTML = '';
        if (!window.__lexicalLog || window.__lexicalLog.length === 0) {
            list.innerHTML = '<div style="color:#999; font-size:12px; padding:6px;">No translations logged yet.</div>';
            return;
        }

        window.__lexicalLog.slice().reverse().forEach((entry, revIdx) => {
            const idx = window.__lexicalLog.length - 1 - revIdx;
            const item = document.createElement('div');
            item.style.padding = '8px';
            item.style.borderBottom = '1px solid rgba(255,255,255,0.02)';
            item.style.display = 'flex';
            item.style.justifyContent = 'space-between';
            item.style.alignItems = 'center';

            const left = document.createElement('div');
            left.style.flex = '1';
            left.innerHTML = `<div style="font-size:12px; color:var(--text-highlight); font-weight:600;">${entry.input}</div>` +
                `<div style="font-size:11px; color:#aaa; margin-top:4px;">${(entry.result.scale && (entry.result.scale.root || entry.result.scale.key) ? (entry.result.scale.root || entry.result.scale.key) + ' ' + (entry.result.scale.name || entry.result.scale.scale || '') : '')} ${entry.result.progression && entry.result.progression.length ? '¬∑ ' + entry.result.progression.map(c=>c.fullName||c).join(' ‚Üí ') : ''}</div>`;

            const actions = document.createElement('div');
            actions.style.display = 'flex';
            actions.style.gap = '6px';

            const sendBtn = document.createElement('button');
            sendBtn.className = 'btn';
            sendBtn.style.fontSize = '0.75rem';
            sendBtn.textContent = 'Send';
            sendBtn.onclick = () => sendLogEntry(idx);

            const exportBtn = document.createElement('button');
            exportBtn.className = 'btn';
            exportBtn.style.fontSize = '0.75rem';
            exportBtn.textContent = 'Export';
            exportBtn.onclick = () => exportLogEntry(idx);

            actions.appendChild(sendBtn);
            actions.appendChild(exportBtn);

            item.appendChild(left);
            item.appendChild(actions);
            list.appendChild(item);
        });
    }

    function sendLogEntry(index) {
        if (!window.__lexicalLog || !window.__lexicalLog[index]) {
            alert('Log entry not found');
            return;
        }
        const entry = window.__lexicalLog[index];
        // Reconstruct a compatible result object for updateNumberGenerator
        const res = {
            scale: entry.result.scale,
            progression: entry.result.progression
        };
        try {
            window.__lastLexicalResult = res;
            updateNumberGenerator(res);
            alert('Sent translation to sheet');
        } catch (err) {
            console.error('Failed to send log entry to sheet', err);
            alert('Failed to send to sheet. See console.');
        }
    }

    function exportLexicalLog() {
        if (!window.__lexicalLog || window.__lexicalLog.length === 0) {
            alert('No lexical log to export');
            return;
        }
        
        // Enhanced JSON export with grading metadata preservation
        const exportData = {
            format: 'JSON',
            version: '1.0',
            timestamp: new Date().toISOString(),
            gradingMetadata: {
                mode: window.musicEngine ? window.musicEngine.gradingMode : 'functional',
                preservationLevel: 'full',
                exportType: 'lexical-log'
            },
            data: {
                lexicalLog: window.__lexicalLog.map(entry => {
                    // Enhance each log entry with grading information if available
                    const enhancedEntry = { ...entry };
                    
                    // Add grading context if musical elements are present
                    if (entry.scale && window.musicEngine) {
                        try {
                            const context = {
                                key: entry.key || 'C',
                                scaleType: entry.scale,
                                elementType: 'scale'
                            };
                            const tier = window.musicEngine.calculateElementGrade(entry.scale, context);
                            const tierInfo = window.musicEngine.getGradingTierInfo(tier);
                            
                            enhancedEntry.grading = {
                                tier,
                                mode: window.musicEngine.gradingMode,
                                label: tierInfo.label,
                                color: tierInfo.color,
                                name: tierInfo.name,
                                explanation: window.musicEngine.getGradingExplanation ? 
                                    window.musicEngine.getGradingExplanation(entry.scale, tier, context) : 
                                    `${entry.scale} receives ${tierInfo.name} grade in ${window.musicEngine.gradingMode} mode`
                            };
                        } catch (e) {
                            // Grading failed, continue without it
                        }
                    }
                    
                    // Add grading for chord progressions if present
                    if (entry.chords && Array.isArray(entry.chords) && window.musicEngine) {
                        enhancedEntry.chordGrading = entry.chords.map(chord => {
                            try {
                                const context = {
                                    key: entry.key || 'C',
                                    scaleType: entry.scale || 'major',
                                    elementType: 'chord'
                                };
                                const tier = window.musicEngine.calculateElementGrade(chord, context);
                                const tierInfo = window.musicEngine.getGradingTierInfo(tier);
                                
                                return {
                                    chord,
                                    tier,
                                    label: tierInfo.label,
                                    color: tierInfo.color,
                                    name: tierInfo.name
                                };
                            } catch (e) {
                                return { chord, tier: 2, label: 'Good', color: '#fbbf24', name: 'Good' };
                            }
                        });
                    }
                    
                    return enhancedEntry;
                })
            },
            metadata: {
                totalEntries: window.__lexicalLog.length,
                exportedAt: new Date().toISOString(),
                gradingMode: window.musicEngine ? window.musicEngine.gradingMode : 'functional',
                gradingVersion: '1.0'
            }
        };
        
        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `lexical-log-enhanced-${new Date().toISOString().replace(/[:.]/g,'-')}.json`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
    }

    // Enhanced JSON export for musical data with grading metadata preservation
    function exportMusicalDataToJSON(musicalData, options = {}) {
        if (!musicalData) {
            console.warn('No musical data provided for export');
            return null;
        }
        
        const exportData = {
            format: 'JSON',
            version: '1.0',
            timestamp: new Date().toISOString(),
            gradingMetadata: {
                mode: window.musicEngine ? window.musicEngine.gradingMode : 'functional',
                preservationLevel: options.preservationLevel || 'full',
                exportType: options.exportType || 'musical-data'
            },
            data: {}
        };

        // Process different types of musical data
        if (musicalData.progression && Array.isArray(musicalData.progression)) {
            exportData.data.progression = musicalData.progression.map((chord, index) => {
                const enhancedChord = { ...chord };
                
                // Add grading information if music engine is available
                if (window.musicEngine && typeof window.musicEngine.calculateElementGrade === 'function') {
                    try {
                        const context = {
                            key: musicalData.key || chord.key || 'C',
                            scaleType: musicalData.scale || chord.scale || 'major',
                            elementType: 'chord',
                            progressionIndex: index
                        };
                        
                        const chordName = chord.name || chord.root + (chord.chordType || '');
                        const tier = window.musicEngine.calculateElementGrade(chordName, context);
                        const tierInfo = window.musicEngine.getGradingTierInfo(tier);
                        
                        enhancedChord.grading = {
                            tier,
                            mode: window.musicEngine.gradingMode,
                            label: tierInfo.label,
                            color: tierInfo.color,
                            name: tierInfo.name,
                            short: tierInfo.short,
                            explanation: window.musicEngine.getGradingExplanation ? 
                                window.musicEngine.getGradingExplanation(chordName, tier, context) : 
                                `${chordName} receives ${tierInfo.name} grade in ${window.musicEngine.gradingMode} mode`
                        };
                    } catch (e) {
                        console.warn('Failed to add grading for chord:', chord, e);
                    }
                }
                
                return enhancedChord;
            });
        }

        // Process scale information
        if (musicalData.scale) {
            exportData.data.scale = {
                name: musicalData.scale,
                key: musicalData.key || 'C'
            };
            
            if (window.musicEngine) {
                try {
                    const context = {
                        key: musicalData.key || 'C',
                        scaleType: musicalData.scale,
                        elementType: 'scale'
                    };
                    const tier = window.musicEngine.calculateElementGrade(musicalData.scale, context);
                    const tierInfo = window.musicEngine.getGradingTierInfo(tier);
                    
                    exportData.data.scale.grading = {
                        tier,
                        mode: window.musicEngine.gradingMode,
                        label: tierInfo.label,
                        color: tierInfo.color,
                        name: tierInfo.name,
                        explanation: window.musicEngine.getGradingExplanation ? 
                            window.musicEngine.getGradingExplanation(musicalData.scale, tier, context) : 
                            `${musicalData.scale} receives ${tierInfo.name} grade in ${window.musicEngine.gradingMode} mode`
                    };
                } catch (e) {
                    console.warn('Failed to add grading for scale:', musicalData.scale, e);
                }
            }
        }

        // Add any additional musical data
        if (musicalData.notes && Array.isArray(musicalData.notes)) {
            exportData.data.notes = musicalData.notes.map(note => {
                const enhancedNote = typeof note === 'string' ? { name: note } : { ...note };
                
                if (window.musicEngine) {
                    try {
                        const context = {
                            key: musicalData.key || 'C',
                            scaleType: musicalData.scale || 'major',
                            elementType: 'note'
                        };
                        const noteName = enhancedNote.name || note;
                        const tier = window.musicEngine.calculateElementGrade(noteName, context);
                        const tierInfo = window.musicEngine.getGradingTierInfo(tier);
                        
                        enhancedNote.grading = {
                            tier,
                            mode: window.musicEngine.gradingMode,
                            label: tierInfo.label,
                            color: tierInfo.color,
                            name: tierInfo.name
                        };
                    } catch (e) {
                        console.warn('Failed to add grading for note:', note, e);
                    }
                }
                
                return enhancedNote;
            });
        }

        // Add metadata about the export
        exportData.metadata = {
            exportedAt: new Date().toISOString(),
            gradingMode: window.musicEngine ? window.musicEngine.gradingMode : 'functional',
            gradingVersion: '1.0',
            dataIntegrity: validateGradingMetadata(exportData),
            originalDataKeys: Object.keys(musicalData)
        };

        return exportData;
    }

    // Grading metadata validation for export integrity
    function validateGradingMetadata(exportData) {
        const validation = {
            hasGradingMode: false,
            hasGradingData: false,
            gradingConsistency: true,
            validTiers: true,
            errors: []
        };

        try {
            // Check if grading mode is present
            if (exportData.gradingMetadata && exportData.gradingMetadata.mode) {
                validation.hasGradingMode = true;
            } else {
                validation.errors.push('Missing grading mode in metadata');
            }

            // Check if any grading data exists
            const checkForGrading = (obj) => {
                if (obj && typeof obj === 'object') {
                    if (obj.grading) {
                        validation.hasGradingData = true;
                        
                        // Validate tier range
                        if (obj.grading.tier < 0 || obj.grading.tier > 4) {
                            validation.validTiers = false;
                            validation.errors.push(`Invalid tier: ${obj.grading.tier}`);
                        }
                        
                        // Check required grading fields
                        const requiredFields = ['tier', 'label', 'color', 'name'];
                        requiredFields.forEach(field => {
                            if (!obj.grading[field]) {
                                validation.gradingConsistency = false;
                                validation.errors.push(`Missing grading field: ${field}`);
                            }
                        });
                    }
                    
                    // Recursively check nested objects
                    Object.values(obj).forEach(value => {
                        if (Array.isArray(value)) {
                            value.forEach(item => checkForGrading(item));
                        } else {
                            checkForGrading(value);
                        }
                    });
                }
            };

            checkForGrading(exportData.data);

        } catch (e) {
            validation.errors.push(`Validation error: ${e.message}`);
        }

        validation.isValid = validation.hasGradingMode && validation.hasGradingData && 
                           validation.gradingConsistency && validation.validTiers && 
                           validation.errors.length === 0;

        return validation;
    }

    // Enhanced sharing functionality with grading metadata preservation
    function shareMusicalDataWithGrading(musicalData, shareFormat = 'JSON', options = {}) {
        if (!musicalData) {
            console.warn('No musical data provided for sharing');
            return null;
        }

        let sharedData;
        const timestamp = new Date().toISOString();

        try {
            switch (shareFormat.toUpperCase()) {
                case 'JSON':
                    sharedData = exportMusicalDataToJSON(musicalData, {
                        ...options,
                        exportType: 'shared-data'
                    });
                    break;
                    
                case 'MIDI':
                    // For MIDI sharing, we need to work with the sheet music generator
                    if (window.sheetMusicGenerator && typeof window.sheetMusicGenerator.buildMidiFile === 'function') {
                        try {
                            const midiData = window.sheetMusicGenerator.buildMidiFile(options);
                            sharedData = {
                                format: 'MIDI',
                                data: midiData,
                                gradingMetadata: {
                                    mode: window.musicEngine ? window.musicEngine.gradingMode : 'functional',
                                    preservedInMidi: true,
                                    version: '1.0'
                                }
                            };
                        } catch (e) {
                            console.warn('MIDI generation failed, falling back to JSON:', e);
                            sharedData = exportMusicalDataToJSON(musicalData, options);
                        }
                    } else {
                        console.warn('MIDI export not available, using JSON format');
                        sharedData = exportMusicalDataToJSON(musicalData, options);
                    }
                    break;
                    
                default:
                    console.warn(`Unsupported share format: ${shareFormat}, using JSON`);
                    sharedData = exportMusicalDataToJSON(musicalData, options);
            }

            // Add sharing metadata
            if (sharedData) {
                sharedData.sharingInfo = {
                    sharedAt: timestamp,
                    format: shareFormat,
                    gradingPreserved: true,
                    gradingMode: window.musicEngine ? window.musicEngine.gradingMode : 'functional',
                    shareId: generateShareId(),
                    integrity: validateGradingMetadata(sharedData)
                };
            }

        } catch (e) {
            console.error('Sharing failed:', e);
            return null;
        }

        return sharedData;
    }

    // Generate a unique share ID for tracking
    function generateShareId() {
        const timestamp = Date.now().toString(36);
        const random = Math.random().toString(36).substr(2, 5);
        return `share_${timestamp}_${random}`;
    }

    // Export shared data as downloadable file
    function downloadSharedData(sharedData, filename) {
        if (!sharedData) {
            console.warn('No shared data to download');
            return;
        }

        const blob = new Blob([JSON.stringify(sharedData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename || `shared-musical-data-${new Date().toISOString().replace(/[:.]/g,'-')}.json`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
    }

    function showDebugLog() {
        let debugInfo = [];
        
        // Check ScaleIntelligenceEngine availability
        debugInfo.push('=== SCALE INTELLIGENCE ENGINE DEBUG ===');
        debugInfo.push(`ScaleIntelligenceEngine defined: ${typeof ScaleIntelligenceEngine !== 'undefined' ? '‚úÖ YES' : '‚ùå NO'}`);
        
        if (typeof ScaleIntelligenceEngine !== 'undefined') {
            try {
                const testEngine = new ScaleIntelligenceEngine();
                debugInfo.push(`ScaleIntelligenceEngine creation: ‚úÖ SUCCESS`);
                debugInfo.push(`Scale database size: ${Object.keys(testEngine.scaleDatabase || {}).length} scales`);
                
                // Test scale selection
                const testResult = testEngine.selectScale({
                    darkness: 0.6, energy: 0.57, mystery: 0.23, brightness: 0, tension: 0.5,
                    words: ['chase', 'woods', 'danger']
                });
                debugInfo.push(`Test selection: ${testResult.name} (${Math.round(testResult.score * 100)}%)`);
                debugInfo.push(`Test reason: ${testResult.primaryReason}`);
                
            } catch (error) {
                debugInfo.push(`ScaleIntelligenceEngine creation: ‚ùå FAILED - ${error.message}`);
            }
        }
        
        // Check SimpleWordEngine status
        debugInfo.push('');
        debugInfo.push('=== SIMPLE WORD ENGINE DEBUG ===');
        debugInfo.push(`lexicalEngine defined: ${lexicalEngine ? '‚úÖ YES' : '‚ùå NO'}`);
        
        if (lexicalEngine) {
            debugInfo.push(`Engine type: ${lexicalEngine.constructor.name}`);
            debugInfo.push(`Scale Intelligence available: ${lexicalEngine.scaleIntelligence ? '‚úÖ YES' : '‚ùå NO'}`);
            debugInfo.push(`Debug mode: ${lexicalEngine.debug ? '‚úÖ ON' : '‚ùå OFF'}`);
            debugInfo.push(`Word mappings: ${Object.keys(lexicalEngine.wordMappings || {}).length} entries`);
        }
        
        // Check recent translations
        debugInfo.push('');
        debugInfo.push('=== RECENT TRANSLATIONS ===');
        if (window.__lexicalLog && window.__lexicalLog.length > 0) {
            const recent = window.__lexicalLog.slice(-3);
            recent.forEach((entry, i) => {
                debugInfo.push(`${i + 1}. "${entry.input}" ‚Üí ${entry.result?.scale?.root || 'unknown'} ${entry.result?.scale?.name || 'unknown'}`);
            });
        } else {
            debugInfo.push('No translations logged yet');
        }
        
        // Show in a modal
        const debugText = debugInfo.join('\\n');
        
        // Create a simple modal-like display
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: #1a1a1a; border: 2px solid var(--accent-primary);
            padding: 20px; border-radius: 8px; z-index: 10000;
            max-width: 600px; max-height: 80vh; overflow: auto;
            font-family: monospace; font-size: 12px; color: #fff;
        `;
        
        modal.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3 style="margin: 0; color: var(--accent-primary);">üîç Debug Information</h3>
                <button onclick="this.parentElement.parentElement.remove()" style="background: none; border: none; color: #fff; font-size: 18px; cursor: pointer;">‚úï</button>
            </div>
            <pre style="margin: 0; white-space: pre-wrap; line-height: 1.4;">${debugInfo.join('\\n')}</pre>
            <div style="margin-top: 15px; text-align: center;">
                <button onclick="navigator.clipboard.writeText(\`${debugText}\`); alert('Debug info copied to clipboard!')" 
                        style="padding: 8px 16px; background: var(--accent-primary); color: #000; border: none; border-radius: 4px; cursor: pointer;">
                    üìã Copy to Clipboard
                </button>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        // Also log to console for backup
        console.log('[DEBUG LOG]\\n' + debugText);
    }

    function exportLogEntry(index) {
        if (!window.__lexicalLog || !window.__lexicalLog[index]) {
            alert('Log entry not found');
            return;
        }
        const entry = window.__lexicalLog[index];
        const blob = new Blob([JSON.stringify(entry, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `lexical-entry-${index + 1}-${new Date().toISOString().replace(/[:.]/g,'-')}.json`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
    }

    // Prevent rapid successive calls and processing locks
    let lastProcessTime = 0;
    let lastProcessWords = '';
    let isProcessing = false;
    let globalProcessingBlock = false;
    
    async function processWordsInput(words) {
        const now = Date.now();
        
        // Debug: Track function calls with detailed stack trace
        console.log('[DEBUG] ========================================');
        console.log('[DEBUG] processWordsInput called with:', words);
        console.log('[DEBUG] Timestamp:', now);
        console.log('[DEBUG] Last process time:', lastProcessTime);
        console.log('[DEBUG] Time since last:', now - lastProcessTime, 'ms');
        console.log('[DEBUG] Last words:', lastProcessWords);
        console.log('[DEBUG] Is processing:', isProcessing);
        console.log('[DEBUG] Full stack trace:');
        console.log(new Error().stack);
        console.log('[DEBUG] ========================================');
        
        // Prevent duplicate calls within 500ms with same words (increased from 200ms)
        if (words === lastProcessWords && (now - lastProcessTime) < 500) {
            console.log('[DEBUG] ‚ùå BLOCKED: Duplicate call within 500ms');
            return;
        }
        
        // Prevent overlapping processing
        if (isProcessing) {
            console.log('[DEBUG] ‚ùå BLOCKED: Already processing');
            return;
        }
        
        // Global processing block check
        if (globalProcessingBlock) {
            console.log('[DEBUG] ‚ùå BLOCKED: Global processing block active');
            return;
        }
        
        console.log('[DEBUG] ‚úÖ PROCEEDING with processing');
        isProcessing = true;
        globalProcessingBlock = true;
        lastProcessTime = now;
        lastProcessWords = words;
        
        // Set a timer to release the global block
        setTimeout(() => {
            globalProcessingBlock = false;
            console.log('[DEBUG] üîì Global processing block released');
        }, 1000); // 1 second block
        
        if (!lexicalEngine) {
            console.warn('[LexicalIntegration] Engine not initialized');
            return;
        }



        try {
            console.log('[LexicalIntegration] Processing words:', words);
            console.log('[LexicalIntegration] Current weights:', lexicalWeights);
            
            // Translate words to music with current weights (now async)
            const result = await lexicalEngine.translateWords(words, { 
                weights: lexicalWeights, 
                aggressive: lexicalSettings.aggressiveMapping,
                dynamicKeys: lexicalSettings.keyVariety 
            });
            console.log('[LexicalIntegration] Translation result:', result);

            // Expose latest result for Send-to-Sheet and other quick actions
            try { window.__lastLexicalResult = result; } catch(_) {}
            
            // Log to global lexical log
            if (!window.__lexicalLog) window.__lexicalLog = [];
            window.__lexicalLog.push({
                type: 'translateWords',
                timestamp: new Date().toISOString(),
                input: words,
                weights: { ...lexicalWeights },
                result: {
                    scale: result.scale,
                    progression: result.progression ? result.progression.map(c => ({
                        fullName: c.fullName || c,
                        degree: c.degree,
                        function: c.function,
                        tier: c.tier
                    })) : [],
                    complexity: result.complexity,
                    reasoning: result.reasoning ? result.reasoning.summary : null
                }
            });
            // Keep log manageable
            if (window.__lexicalLog.length > 50) window.__lexicalLog.shift();
            // Refresh in-page log (if present)
            try { renderLexicalLog(); } catch(_) {}

            // Update analysis panel
            updateAnalysisPanel(result);

            // Extract chord degrees and update NumberGenerator
            if (result.progression && result.progression.length > 0) {
                // Only auto-send if setting is enabled
                if (lexicalSettings.autoSend) {
                    updateNumberGenerator(result);
                    console.log('[LexicalIntegration] Auto-sent to sheet music');
                } else {
                    console.log('[LexicalIntegration] Auto-send disabled, use üéº button');
                }
            } else {
                console.warn('[LexicalIntegration] No progression generated');
            }
            
            // Save to undo/redo history
            saveToHistory();

        } catch (err) {
            console.error('[LexicalIntegration] Translation error:', err);
            console.error('[LexicalIntegration] Error stack:', err.stack);
        } finally {
            // Always reset processing flag
            isProcessing = false;
            console.log('[DEBUG] Processing flag reset');
        }
    }

    function updateAnalysisPanel(result) {
        const analysisContent = document.getElementById('word-analysis-content');
        const analysisPanel = document.getElementById('word-analysis-panel');
        
        console.log('[updateAnalysisPanel] Called with result:', result);
        console.log('[updateAnalysisPanel] analysisContent:', analysisContent);
        console.log('[updateAnalysisPanel] analysisPanel:', analysisPanel);
        
        if (!analysisContent || !result) {
            console.warn('[updateAnalysisPanel] Missing content or result');
            return;
        }

        let html = '';

        // CURRENT WEIGHTS DISPLAY (NEW!)
        html += `
            <div class="analysis-section" style="background: rgba(147,51,234,0.15); border-left: 3px solid #9333ea;">
                <div class="analysis-section-title">‚öñÔ∏è CURRENT WEIGHTS</div>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; font-size: 11px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="color: #aaa;">Emotional:</span>
                        <span style="font-weight: bold; color: #64C8FF;">${Math.round((lexicalWeights.emotional || 0) * 100)}%</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="color: #aaa;">Semantic:</span>
                        <span style="font-weight: bold; color: #10b981;">${Math.round((lexicalWeights.semantic || 0) * 100)}%</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="color: #aaa;">Phonetic:</span>
                        <span style="font-weight: bold; color: #f59e0b;">${Math.round((lexicalWeights.phonetic || 0) * 100)}%</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="color: #aaa;">Syllabic:</span>
                        <span style="font-weight: bold; color: #8b5cf6;">${Math.round((lexicalWeights.syllabic || 0) * 100)}%</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="color: #aaa;">Archetype:</span>
                        <span style="font-weight: bold; color: #ec4899;">${Math.round((lexicalWeights.archetype || 0) * 100)}%</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="color: #aaa;">Aggressive:</span>
                        <span style="font-weight: bold; color: ${lexicalSettings.aggressiveMapping ? '#ef4444' : '#666'};">${lexicalSettings.aggressiveMapping ? 'ON' : 'OFF'}</span>
                    </div>
                </div>
                <div style="font-size: 10px; color: #666; margin-top: 8px; font-style: italic;">
                    üí° Tip: Click üé≤ to randomize weights or ‚öôÔ∏è to adjust manually
                </div>
            </div>
        `;

        // REASONING SECTION (NEW!)
        if (result.reasoning) {
            html += `
                <div class="analysis-section" style="background: rgba(100,200,255,0.1); border-left: 3px solid #64C8FF;">
                    <div class="analysis-section-title">üí° REASONING</div>
                    <div class="analysis-item" style="font-size: 13px; line-height: 1.6;">
                        ${result.reasoning.summary}
                    </div>
                </div>
            `;
        }

        // Scale section with reasoning
        if (result.scale) {
            html += `
                <div class="analysis-section">
                    <div class="analysis-section-title">üéµ Scale Suggestion</div>
                    <div class="analysis-item">
                        <span class="analysis-item-label">Key:</span>
                        <span class="analysis-item-value">${result.scale.root || result.scale.key || 'C'}</span>
                    </div>
                    <div class="analysis-item">
                        <span class="analysis-item-label">Scale:</span>
                        <span class="analysis-item-value">${result.scale.name || result.scale.scale || 'major'}</span>
                    </div>
                    ${result.reasoning && result.reasoning.scaleChoice ? `
                    <div class="analysis-item" style="font-size: 11px; color: #aaa; font-style: italic; margin-top: 4px;">
                        Why: ${result.reasoning.scaleChoice}
                    </div>
                    ` : ''}
                </div>
            `;
        }

        // Progression section WITH TIER INFO & FUNCTIONAL HARMONY
        if (result.progression && result.progression.length > 0) {
            html += `<div class="analysis-section">
                    <div class="analysis-section-title">üéπ Chord Progression</div>`;
            
            result.progression.forEach((chord) => {
                // Get tier info for color
                const tierColor = chord.tierInfo ? chord.tierInfo.color : '#666';
                const tierLabel = chord.tierInfo ? chord.tierInfo.label : '';
                const tierStars = chord.tier ? '‚òÖ'.repeat(chord.tier) : '';
                
                // Chord name
                let chordName;
                if (typeof chord === 'string') {
                    chordName = chord;
                } else if (chord.fullName) {
                    chordName = chord.fullName;
                } else if (chord.root && chord.chordType !== undefined) {
                    chordName = chord.root + chord.chordType;
                } else {
                    chordName = String(chord);
                }
                
                html += `
                    <div class="analysis-item" style="border-left: 3px solid ${tierColor}; padding-left: 8px; margin-bottom: 8px;">
                        <span class="analysis-item-value" style="font-weight: 500;">${chordName}</span>`;
                
                // Show function and tier
                if (chord.function && chord.tier) {
                    html += `<div style="font-size: 11px; color: #aaa; margin-top: 2px;">${chord.function}, Tier ${chord.tier} ${tierStars}</div>`;
                }
                
                // Show reasoning for this chord
                if (chord.reasoning) {
                    html += `<div style="font-size: 11px; color: #888; margin-top: 4px; font-style: italic;">‚Üí ${chord.reasoning}</div>`;
                }
                
                html += `</div>`;
            });
            
            // Show progression logic
            if (result.reasoning && result.reasoning.progressionLogic) {
                html += `<div class="analysis-item" style="font-size: 11px; color: #888; font-style: italic; margin-top: 8px;">
                    Progression Logic: ${result.reasoning.progressionLogic}
                </div>`;
            }
            
            html += `</div>`;
        }

        // Complexity section
        if (result.complexity) {
            const isNumeric = typeof result.complexity === 'object' && 
                             result.complexity.harmonic !== undefined;
            if (isNumeric) {
                html += `
                    <div class="analysis-section">
                        <div class="analysis-section-title">‚öôÔ∏è Complexity</div>
                        <div class="analysis-item">
                            <span class="analysis-item-label">Harmonic:</span>
                            <span class="analysis-item-value">${Math.round(result.complexity.harmonic * 100)}%</span>
                        </div>
                        <div class="analysis-item">
                            <span class="analysis-item-label">Rhythmic:</span>
                            <span class="analysis-item-value">${Math.round(result.complexity.rhythmic * 100)}%</span>
                        </div>
                        <div class="analysis-item">
                            <span class="analysis-item-label">Emotional:</span>
                            <span class="analysis-item-value">${Math.round(result.complexity.emotional * 100)}%</span>
                        </div>
                        <div class="analysis-item">
                            <span class="analysis-item-label">Overall:</span>
                            <span class="analysis-item-value">${result.complexity.overall || 'moderate'}</span>
                        </div>
                    </div>
                `;
            } else {
                html += `
                    <div class="analysis-section">
                        <div class="analysis-section-title">‚öôÔ∏è Complexity</div>
                        <div class="analysis-item">
                            <span class="analysis-item-value">${result.complexity}</span>
                        </div>
                    </div>
                `;
            }
        }

        // Archetype matches
        if (result.archetypeMatch) {
            html += `
                <div class="analysis-section">
                    <div class="analysis-section-title">üé≠ Archetype Match</div>
                    <div class="archetype-match">
                        <div class="archetype-match-title">${result.archetypeMatch.name}</div>
                        ${result.archetypeMatch.description ? `<div style="font-size: 11px; color: #aaa; font-style: italic; margin-top: 4px;">${result.archetypeMatch.description}</div>` : ''}
                    </div>
                </div>
            `;
        } else if (result.analyses && result.analyses.archetypes) {
            const archetypes = result.analyses.archetypes;
            if (archetypes.matches && archetypes.matches.length > 0) {
                const topMatch = archetypes.matches[0];
                html += `
                    <div class="analysis-section">
                        <div class="analysis-section-title">üé¨ Archetype Match</div>
                        <div class="archetype-match">
                            <div class="archetype-match-title">${topMatch.name}</div>
                            <div class="archetype-match-confidence">Confidence: ${Math.round(topMatch.confidence * 100)}%</div>
                        </div>
                    </div>
                `;
            }
        }

        // WORD-BY-WORD ANALYSIS (collapsible, NEW!)
        if (result.reasoning && result.reasoning.wordAnalyses && result.reasoning.wordAnalyses.length > 0) {
            html += `
                <details class="analysis-section" style="cursor: pointer;" open>
                    <summary style="font-weight: bold; cursor: pointer;">üìù WORD-BY-WORD ANALYSIS (Rich Attributes)</summary>
                    <div style="padding-left: 12px; margin-top: 8px; border-left: 2px solid #444;">`;
            
            result.reasoning.wordAnalyses.forEach(wa => {
                const ma = wa.musicalAttributes || {};
                html += `
                    <div style="margin-bottom: 16px; background: rgba(100,200,255,0.05); padding: 10px; border-radius: 4px;">
                        <div style="font-weight: 600; color: #64C8FF; margin-bottom: 6px; font-size: 13px;">"${wa.word}"</div>
                        <div style="font-size: 11px; color: #aaa; line-height: 1.6;">
                            <strong>Emotional:</strong> valence: ${wa.emotional.valence.toFixed(2)}, arousal: ${wa.emotional.arousal.toFixed(2)}, dominance: ${wa.emotional.dominance.toFixed(2)}<br>`;
                
                // Show musical attributes if available
                if (ma.tension !== undefined) {
                    html += `<strong>Tension:</strong> ${Math.round(ma.tension*100)}% `;
                    html += ma.tension > 0.6 ? '‚ö° high' : ma.tension < 0.3 ? 'üïäÔ∏è low' : '‚öñÔ∏è moderate';
                    html += '<br>';
                }
                
                if (ma.color) {
                    html += `<strong>Color:</strong> ${Math.round(ma.color.warmth*100)}% warm, ${Math.round(ma.color.brightness*100)}% bright<br>`;
                }
                
                if (ma.texture) {
                    html += `<strong>Texture:</strong> ${Math.round(ma.texture.density*100)}% density, ${Math.round(ma.texture.spread*100)}% spread<br>`;
                }
                
                if (ma.motion) {
                    const dir = ma.motion.direction > 0.3 ? '‚ÜóÔ∏è ascending' : ma.motion.direction < -0.3 ? '‚ÜòÔ∏è descending' : '‚ü∑ static';
                    html += `<strong>Motion:</strong> ${dir}, ${Math.round(ma.motion.smoothness*100)}% smooth<br>`;
                }
                
                if (ma.register) {
                    html += `<strong>Register:</strong> ${ma.register.preferred} (${ma.register.range.toFixed(1)} octaves), ${ma.register.emphasis} emphasis<br>`;
                }
                
                if (ma.intervals && ma.intervals.preferred && ma.intervals.preferred.length > 0) {
                    html += `<strong>Intervals:</strong> prefers ${ma.intervals.preferred.slice(0,3).join(', ')}<br>`;
                }
                
                html += `</div>`;
                
                if (wa.implications && wa.implications.reasoning && wa.implications.reasoning.length > 0) {
                    html += '<div style="margin-top: 6px; padding-left: 8px; border-left: 2px solid #444;"><ul style="margin: 4px 0; padding-left: 20px; font-size: 10px; color: #888;">';
                    wa.implications.reasoning.slice(0,3).forEach(r => {
                        html += `<li style="margin: 2px 0;">${r}</li>`;
                    });
                    html += '</ul></div>';
                }
                html += `</div>`;
            });
            
            html += `</div></details>`;
        }

        analysisContent.innerHTML = html || '<div class="analysis-empty">No analysis data available</div>';
        
        console.log('[updateAnalysisPanel] HTML length:', html.length);
        console.log('[updateAnalysisPanel] Will show panel:', !!(html && analysisPanel));
        
        // Auto-show panel if it has content
        if (html && analysisPanel) {
            console.log('[updateAnalysisPanel] Adding active class to panel');
            // Only show panel if user isn't trying to dismiss it
            if (!isUserDismissingPanel) {
                analysisPanel.classList.add('active');
            } else {
                console.log('[updateAnalysisPanel] User is dismissing panel, not auto-showing');
                // Reset flag after a short delay to allow normal operation later
                setTimeout(() => {
                    isUserDismissingPanel = false;
                }, 500);
            }
        } else {
            console.warn('[updateAnalysisPanel] Not showing panel - html:', !!html, 'panel:', !!analysisPanel);
        }
    }

    function updateNumberGenerator(result) {
        // Extract chord degrees from progression and send to sheet music
        if (!result.scale || !result.progression) {
            console.warn('[LexicalIntegration] Missing scale or progression');
            return;
        }

        try {
            // Get NumberGenerator instance
            const numGen = window.numberGenerator;
            
            if (!numGen) {
                console.warn('[LexicalIntegration] NumberGenerator not available');
                return;
            }

            // Set the scale first
            const scaleKey = result.scale.root || result.scale.key || 'C';
            const scaleName = result.scale.name || result.scale.scale || 'major';
            console.log('[LexicalIntegration] Setting scale:', scaleKey, scaleName);
            console.log('[LexicalIntegration] Full scale object:', result.scale);
            
            // Update scale library if available
            if (window.scaleLibrary) {
                // Set key first, then scale
                window.scaleLibrary.setKeyAndScale(scaleKey, scaleName);
            }
            
            // Build chord tokens (handle both strings and objects)
            const chordTokens = result.progression.map(chord => {
                if (typeof chord === 'string') return chord;
                if (chord.fullName) return chord.fullName;
                if (chord.root && chord.chordType !== undefined) return chord.root + chord.chordType;
                return String(chord);
            });
            
            console.log('[LexicalIntegration] Chord tokens:', chordTokens);
            
            // Update the manual numbers input field for visibility
            if (window.globalManualNumbers) {
                window.globalManualNumbers.value = chordTokens.join(' ');
            }
            
            // Use setDisplayTokens method - this is the proper way to update NumberGenerator
            if (typeof numGen.setDisplayTokens === 'function') {
                console.log('[LexicalIntegration] Calling setDisplayTokens with:', chordTokens);
                numGen.setDisplayTokens(chordTokens, { 
                    rawTokens: chordTokens,
                    render: true,
                    emit: true
                });
                console.log('[LexicalIntegration] ‚úì Successfully sent to sheet music');
                showToast('üéº Sent to sheet music', '#10b981');
            } else {
                console.warn('[LexicalIntegration] NumberGenerator.setDisplayTokens not available');
            }

        } catch (err) {
            console.error('[LexicalIntegration] Error updating NumberGenerator:', err);
            console.error('[LexicalIntegration] Stack:', err.stack);
        }
    }

})();
    </script>
</body>
</html>
